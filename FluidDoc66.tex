% Präambel
%{{{
% Basics
\documentclass[10pt,DIV=14,a4paper]{scrartcl}
\usepackage[ngerman]{babel}
\usepackage[utf8x]{inputenc}

% Grundlegende Pakete
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{graphicx}
\usepackage{color}
\usepackage{hyperref}

% Einfache Anpassungen und PDF-Metadaten
\parindent 0em
\parskip 1em
\definecolor{darkblue}{rgb}{0,0,0.5}
\hypersetup{
	pdftitle={Fluid-Simulation 0.6.6},
	pdfauthor={TroY},
	pdfkeywords={AoI, Physics, Fluid},
	%
	colorlinks=true,
	breaklinks=true,
	linkcolor=black,
	menucolor=darkblue,
	urlcolor=darkblue
}


% Meine sonstigen Sachen
\input{shortcuts}
\input{listings}
\input{pagestyle}

% Befehle nur für dieses Dokument
\input{customcommands}
%}}}


\begin{document}


% Titelseite mit Copyleft
%{{{
\author{TroY}
\title{\fluidsim 0.6.6 \\ mit Art of Illusion}
\date{April 2009}
\maketitle
\thispagestyle{empty}

\vspace{120mm}

\begin{center}
	\url{http://www.uninformativ.de} \\
	\url{http://www.aoi-board.de}

	Dieses Dokument steht unter der \\
	\textit{Creative Commons Attribution-Noncommercial-Share Alike 3.0 Germany License}, \\
	\url{http://creativecommons.org/licenses/by-nc-sa/3.0/de/}.

	\includegraphics[scale=0.5]{gfx/cc.pdf} \\
	\url{http://creativecommons.org/}
\end{center}

\pagebreak
%}}}

% Inhaltsverzeichnis
%{{{
\tableofcontents
\thispagestyle{empty}
\pagebreak
%}}}


% Dokument
\section{Einleitung}
%{{{

%{{{
Bereits seit 2005 arbeitet \deltor an einem Plugin zur Physiksimulation,
was zu Beginn ein reines Plugin für \blender werden sollte. Er entdeckte
dann zwar recht bald, dass in dieser Hinsicht bereits andere
Programmierer an der Arbeit waren, entschied sich aber trotzdem dafür,
sein eigenes Plugin weiterzuentwickeln -- zum Vorteil für die Nutzer von
\aoi. Denn auf unser schönes Programm stieß \deltor erst Anfang 2007.
Der Kern seiner Simulation war seit jeher in Java geschrieben, was der
Integration mit \aoi natürlich sehr entgegen kam. So nahmen die Dinge
dann ihren Lauf.

\deltor's Plugin ist zwar immernoch in einer recht frühen
Entwicklungsphase, aber es ist durchaus schon zu gebrauchen -- und sei
es nur, um Spaß zu haben. Die jeweils aktuelle Version ist in seinem
Blog verlinkt:

\url{http://delt0r.blogspot.com/}

Da es an Dokumentation jedoch ein bisschen mangelt, die Informationen in
Foren verstreut sind und nicht jeder die Zeit hat, sich mittels ">Trial
and Error"< einzuarbeiten, entstand dieser Guide, um den Einstieg etwas
zu erleichtern. Eigentlich ist das schon die zweite Anleitung dieser
Art, denn bereits von eineinhalb Jahren habe ich eine solche
geschrieben. Bis vor kurzem war sie noch zu gebrauchen, aber Anfang
April 2009 gab es dann einen etwas größeren Sprung in der Entwicklung,
sodass spätestens jetzt eine Aktualisierung notwendig wurde.

Es sei angemerkt, dass dies keine offizielle Dokumentation ist. Dennoch
will ich versuchen, die Vorgänge so genau wie möglich darzustellen und
auf möglichst alle Optionen einzugehen.
%}}}

\subsection{Installation}
%{{{
Die Installation gestaltet sich denkbar einfach: Man besucht \deltor's
Blog, sucht den jeweils aktuellen Link und lädt eine Datei namens
\texttt{Physics.jar} herunter. Diese Datei muss dann in den Unterordner
\texttt{Plugins} des \aoi-Verzeichnisses kopiert werden. Fertig.

Um die Version~0.6.6 nutzen zu können, sollte man am besten \aoi
in der Version~2.7.2 verwenden. Für den Fall, dass \aoi noch gar nicht
installiert ist, kann man es sich unter folgender URL herunterladen:

\url{http://www.artofillusion.org}
%}}}

\subsection{Funktion und Einsatzzweck der Simulation}
%{{{
Wie der Name schon vermuten lässt, ist der primäre Zweck, Flüssigkeiten
zu simulieren. Diese entstehen in sogenannten \fachb{Emitters} und
interagieren dann mit als \fachb{Boundary} definierten Objekten in der
Szene.\footnote{Dem Plugin fehlt noch eine deutsche Übersetzung, daher
werde ich mich hier an die englischen Begriffe halten, um Verwirrung zu
vermeiden. Sollte der eine oder andere Begriff Probleme bereiten, dann
findet sich hier ein erstklassiges Online-Wörterbuch:
\url{http://dict.leo.org}} Alternativ kann man auch ganze Objekte
als \fachb{Fluid} vordefinieren, um auf einen Schlag viel Flüssigkeit in die
Szene zu bringen.

Mittlerweile beherrscht das Plugin jedoch auch die Simulation
sogenannter \fachb{Soft Bodies}. Damit sind Körper gemeint, die im
Wesentlichen deformierbar sind, also zum Beispiel Gummibälle oder
Textilien. Man kann damit in gewissem Rahmen zwar auch feste Körper
simulieren, stößt aber bald an die Grenzen. Die Gründe dafür werden
später näher erläutert. Eine richtige Simulation starrer Körper
(\fachb{Rigid Bodies}) wird es erst in Zukunft geben.

Das Plugin ist dabei auch tatsächlich eine \emph{Simulation}. Leider
steht das in einem gewissen Widerspruch zu dem ">Art"< in \aoi.
Simulationen versuchen, der Realität ähnlich zu sein, was zur Folge hat,
dass man sie nur sehr schwer kontrollieren kann. Es ist beispielsweise
nicht einfach, ein fertiges Bild, das das Anstoßen zweier Bierkrüge,
wobei der Inhalt des einen in den anderen überschwappt, mit der
\fluidsim ">mal eben"< etwas aufzupeppen. Stattdessen muss eine
Animation erstellt werden, welche die Bierkrüge im Vorfeld genau so
bewegt, dass die in ihnen enthaltene Flüssigkeit dann auch tatsächlich
im richtigen Moment ">schwappt"<.  Das ist nicht einfach, da sich die
Flüssigkeit realitätsgetreu verhält und man die Krüge nicht mit den
Händen \emph{anfassen} kann. Dadurch wird das Einschätzen der
vorhandenen Massen und wirkenden Kräfte zu keiner leichten Aufgabe.

Auf der anderen Seite ist aber genau das die Herausforderung.

Abgesehen von den künstlerischen Aspekten bietet die Simulation
natürlich eine großartige Spielwiese. Es macht einfach Spaß, einen Turm
aus Kisten zu bauen und dann zuzusehen, wie dieser durch Wasser
weggespült wird. Oder die Simulation einer Kegelbahn. Oder nachgebildete
Hydraulik, die vielleicht sogar einem kleinen Roboter Leben einhaucht.
Oder die realitätsgetreue Darstellung von Kleidung und Stoffen.
Zusammen mit \aoi's Fähigkeiten zur Animation bieten sich nahezu
unendliche Möglichkeiten, da hier auch Prozeduren und Skripte genutzt
werden können.

In diesem Sinne: Viel Spaß!
%}}}

%}}}


\pagebreak
\section{Grundlagen}
%{{{

\subsection{Animationen und \fachb{Baking}}
%{{{
In der Einleitung fiel bereits das entscheidende Stichwort: Animation.
Die \fluidsim beschreibt Vorgänge, die sich zusammen mit der Zeit
verändern. Man kommt also nicht umhin, eine Animation zu erstellen --
auch, wenn man am Ende nur ein einzelnes Bild rendern möchte. Das wäre
zwar nicht allzu viel Arbeit (Animation ist schließlich eine der
Hauptaufgaben von \aoi), aber die \fluidsim nimmt sie uns großteils
sogar ab. Das Minimum ist jedoch, sich die \emph{Zeitleiste} zugänglich
zu machen. Im Normalfall muss man dazu nichts weiter tun, als den Rand
am unteren Ende des \aoi-Hauptfensters mit der Maus ein Stück nach oben
zu ziehen. Mit dieser Leiste ist es möglich, innerhalb einer Animation
zu navigieren.

\fpic{gfx/shots/TimeScore.png}{fig:timescore}
{\aoi mit sichtbarer Zeitleiste. An der orange markierten Stelle muss
gezogen werden, der grüne Schieber dient zum Setzen des Zeitpunktes.}

Mit den weiteren Möglichkeiten zur Animation muss man sich vorerst nicht
befassen. Wir werden allerdings später darauf zurückkommen, wenn wir das
Rendern von Einzelbildern hinter uns haben und uns um echte Animationen
kümmern.

Da die Berechnungen, welche die \fluidsim anstellt, ziemlich aufwändig
sind, können sie nicht in Echtzeit erfolgen. Die Simulation muss also
vor dem eigentlichen Rendern vorberechnet werden. Dieser Vorgang wird
\fachb{Baking} genannt und wird aus dem Plugin heraus angestoßen. Erst
hiernach hat es auch wirklich eine Auswirkung, wenn man den aktuellen
Zeitpunkt in der Zeitleiste verändert, und die Objekte bewegen sich.

Die Daten werden dabei in einer Datei zwischengespeichert. Man sollte
hier nicht zu geizig sein und sich mit einem fast vollen Datenträger
begnügen: Diese Datei kann bei langen Simulationen mehrere hundert
Megabyte groß werden.
%}}}

\subsection{Zeitschritte und Partikelgrößen}
%{{{
Eine physikalische Simulation läuft am Computer immer ">diskretisiert"<
ab, das heißt, es gibt nur eine endliche Anzahl fester Zeitpunkte, die
berechnet werden. Dazwischen gibt es zwangsweise ">Lücken"<. Daraus
folgt natürlich, dass eine Simulation dann genauer wird, wenn diese
Zeitpunkte näher beeinander liegen. Der Abstand zweier solcher
Zeitpunkte wird im Plugin \fachb{Step Size} genannt.

Man muss hier einen guten Kompromiss finden: Ist die Step Size zu groß,
dann ist die Simulation zwar sehr schnell berechnet, aber höchst
ungenau. Es kann dann passieren, dass Flüssigkeitspartikel ihre
Hindernisse ">überspringen"<. Wird die Step Size dagegen zu klein
gewählt, dauert es einfach zu lange, bis der Baking-Vorgang beendet
ist.\footnote{Eine schöne Anekdote zu diesem Thema findet sich übrigens
hier: \url{http://xkcd.com/505/}}

\fpic{gfx/skizzen/diskrfehler.pdf}{fig:diskrfehler}
{Ein simuliertes Partikel übersieht ein Hindernis durch eine zu große
Step Size.}

Die Flüssigkeiten werden intern als kleine Partikel fester Größe
modelliert, anhand des Parameters \fachb{Particle Size}. Wie man schon
erahnen kann, gilt hier ein ähnlicher Zusammenhang: Sind die Partikel
sehr klein, dann ist die Simulation sehr detailliert, aber langsam. Sind
sie zu groß, simuliert man irgendwann Fußbälle.

Bei beiden Parametern sind Werte voreingestellt, die für einfache
Beispiele ausreichend sind.

Man muss wissen, dass hier ein loser Zusammenhang herrscht. Verringert
man die Partikelgröße, dann sollte man auch die Zeitschritte verringern.
Eine feste Formel hierfür anzugeben, wäre aber nicht sonderlich
praktikabel. Der Grund für diesen Zusammenhang ist, dass kleinere
Partikel noch leichter Hindernisse überspringen oder gegenseitig
ineinander eindringen können, als dass bei größeren Partikeln der Fall
ist. Grob lässt sich sagen: Halbiert man die Particle Size, dann sollte
man auch die Step Size halbieren.

\fpic{gfx/skizzen/zshg-groesse-step.pdf}{fig:zshg-groesse-step}
{Bei größeren Partikeln wird noch eine Kollision erkannt, während
kleinere Partikel in derselben Simulation wieder durch das Objekt
tunneln.}

In Abbildung~\ref{fig:zshg-groesse-step} wird auch noch einmal die
grundsätzliche Bedeutung der Step Size deutlich: Auch die großen
Partikel würden durch das Hindernis tunneln, wenn sie sich schneller
bewegen würden. Eine höhere Geschwindigkeit heißt, dass die Partikel pro
Zeitschritt eine größere Distanz zurücklegen, wodurch natürlich die
Lücken zwischen ihnen größer werden. Damit steigt die Chance, dass ein
Teilchen ein Hindernis nicht wahrnimmt. Man muss also auch dann, wenn
man in einer Simulation hohe Geschwindigkeiten hat, eine kleine Step
Size wählen.

In ferner Zukunft soll es dafür eine Lösung geben und zwar eine adaptive
Step Size. Inwiefern das funktionieren und wann es überhaupt eingebaut
wird, ist aber noch offen.
%}}}

%}}}


\pagebreak
\section{Flüssigkeitssimulation}
%{{{

%{{{
Die konkrete Anwendung der \fluidsim erklärt man wohl am besten anhand
eines Beispiels. Im ersten Teil soll unser Ziel sein,
\enumA
	\item ein gefülltes Becken mit Wasser zu erstellen,
	\item Wasser aus einer Quelle herausfließen zu lassen.
\enumE
%}}}

\subsection{Das gefüllte Becken (\fachb{Boundaries} und \fachb{Fluids})}
%{{{
Zuerst werden wir das Becken als Boundary definieren. Seit einiger Zeit
unterstützt das Plugin sogenannte \fachb{Poly Boundaries}, also Objekte,
deren \emph{Flächen} als Hindernis benutzt werden können.\footnote{In
älteren Versionen war das anders. Früher galten die Punkte eines
Objektes als Grenzen, was einiges an Zwischenarbeit erforderte.} Das
heißt für uns, dass wir ganz komfortabel ein \PolyMesh-Objekt in die
Szene bringen und dieses unverändert nutzen können. Tun wir das also und
erstellen uns ein sehr rudimentäres Becken. Um die Übersicht zu wahren,
nennen wir es um in ">Becken"<.

Eine kurze Randbemerkung: Primitive \aoi-Objekte, also Würfel, Kugeln
oder Zylinder, können nicht als Hindernisse in der \fluidsim verwendet
werden.

\fpic{gfx/shots/Becken1.png}{fig:becken1}
{Ein einfaches Becken.}

Wie eingangs erwähnt, lassen sich Objekte als Fluid definieren und
werden damit komplett flüssig. Genau das wollen wir jetzt nutzen: Wir
erstellen einen weiteren, einfachen \PolyMesh-Quader, den wir in das
Becken setzen. Noch ist er solide, aber das wird sich bald ändern. Wir
nennen ihn ">Fuellung"<.

\fpic{gfx/shots/Becken2.png}{fig:becken2}
{Das Becken mit (noch) solider Füllung.}

Um Objekten physikalische Eigenschaften zuordnen zu können, muss zuerst
eine Instanz des Fluid-Plugins zur Szene hinzugefügt werden. Man wählt
dazu einfach die blauen Tröpfchen aus der Toolbar aus und zieht ein
Rechteck auf. Was man im nächsten Schritt sieht, ist das Drahtgitter
eines Würfels. Dieser Bereich ist wichtig: Er definiert, wo
Flüssigkeiten existieren können und wo nicht. Verlassen Partikel diesen
Würfel, werden sie automatisch verschwinden. Es ist aber kein Problem,
den Bereich später einfach mit dem gewohnten Skalierungstool zu
erweitern.

Ein Doppelklick auf das neu erstellte Objekt in der Objektliste öffnet
seine Eigenschaften. Hier wird sich nun die ganze Magie abspielen.

Wir markieren das Objekt ">Becken"< in der mittleren
Liste.\rand{Boundary} Um einem Objekt Eigenschaften zuzuweisen, müssen
wir es erst in die aktuelle ">Auswahl"< übernehmen. Die
Begrifflichkeiten kollidieren hier leider etwas, denn diese Auswahl hat
nichts mit den \fachb{Selection Sets} in der linken Hälfte des Dialogs
zu tun -- zu denen kommen wir erst später. Die Auswahl, um die es hier
geht, bestimmt nur jene Objekte, auf die die gesetzten Parameter wirken.
Man könnte in der mittleren Liste also auch mehrere Objekte auf einmal
markieren und diese damit gleichzeitig bearbeiten.

Aus der rechten Dropdown-Liste wählen wir nun ">Boundry"<\footnote{Die
Rechtschreibfehler stehen weiter unten auf der ">TODO"<-Liste...} und
klicken auf ">Set To Selection"<. Es werden jetzt ein paar mehr Optionen
zugänglich, für unser Beispiel sind diese aber optimal.

Als nächstes erklären wir den inneren Quader zur
Flüssigkeit.\rand{Fluid} Auch dieser Vorgang gestaltet sich ziemlich
einfach: Das Objekt namens ">Fuellung"< aus der mittleren Liste wählen,
auf ">Set To Selection"< klicken und diesmal weisen wir ihm den Typ
">Fluid"< zu. Das war's.

\fpic{gfx/shots/Becken-Definitionen.png}{fig:becken-def}
{Die ersten zwei Objekte sind im Plugin definiert.}

Jetzt können wir auch schon den ersten ">Backvorgang"<
starten.\rand{Baking} Dazu wechseln wir auf den Tab ">Baking"<. Hier
kann man einen Zielort für die temporäre Datei angeben, der Standardwert
sollte aber vorübergehend ausreichen. Wichtig ist: Wenn man von vorne
mit der Simulation anfangen will, sollte man immer die beiden Knöpfe
betätigen:

\itA
	\item ">\textbf{Clear Object Cache}"<: Dieser Knopf signalisiert dem
	Plugin, dass es bitte alle zwischengespeicherten Informationen über
	die vorhandenen Objekte vergessen möge, vorallem deren Geometrie.
	Das heißt, diesen Knopf müsste man auch betätigen, wenn man im
	Nachhinein die Größe des Beckens ändern wollte.

	\item ">\textbf{Reset Simulation}"<: Dagegen sorgt dieser zweite
	Knopf dafür, dass sowohl die Zeit auf Null zurückgesetzt als auch
	alle bisher berechneten Bewegungen gelöscht werden. Das muss man
	also zusätzlich auslösen, wenn man sicherstellen will, dass die
	Simulation auch wirklich von vorne anfängt zu rechnen.

\itE

Im unteren Feld können wir noch eingeben, zu welchem Zeitpunkt die
Simulation enden soll. Dieser Zeitpunkt ist \emph{absolut}, das heißt,
er bestimmt \emph{nicht die Dauer} der Simulation. Wir schreiben also
eine ">2"< in das Feld, da wir von Sekunde 0 bis Sekunde 2 simulieren
wollen.

Nach einem Klick auf ">Bake"< erscheint ein Fortschrittsbalken, der aber
bald wieder verschwindet. Verlässt man nun das Plugin mit einem Klick
auf ">OK"< und bewegt danach den Schieber in der Zeitleiste etwas,
sollte man auch schon die ersten Anzeichen von Leben in der Flüssigkeit
entdecken können.

Bevor man ein halbwegs sinnvolles Bild rendern kann, heißt es jedoch:

\itA
	\item Licht muss in die Szene. Dieser Schritt ist trivial und zur
	Not schlage man im Handbuch\footnote{Hier die deutsche Übersetzung
	von Vidiot: \\
	\url{http://www.uninformativ.de/tutorials/Vidiot/AoI_Manual_2_6_ger/contents_de.html}}
	nach. ;-)

	\item Man will vermutlich das \PolyMesh-Objekt ">Fuellung"<
	verstecken. Der Grund dafür ist, dass das Setzen des Objektes auf
	">Fluid"< das originale Objekt nicht beeinflusst. Es dient quasi nur
	als Partikelquelle und ist daher im Normalfall im Weg.

	Keine Sorge, die Flüssigkeit wird dadurch nicht unsichtbar, denn
	diese ist Teil des Objektes ">PhysicsObject 1"<. Würde man also
	tatsächlich die Flüssigkeit \emph{nicht} rendern wollen, so müsste
	man das gesamte Physik-Objekt verstecken. Im Moment ist es noch
	nicht möglich, nur einzelne Teile des Physik-Objektes zu verstecken.

\itE

Abbildung~\ref{fig:render-becken1} zeigt dann, wie ein mögliches
Ergebnis aussehen kann.

\fpic{gfx/renders/Becken1.png}{fig:render-becken1}
{Ein erster Testrender der Szene mit transparentem Hintergrund.}
%}}}

\subsection{Erweiterte Optionen zum vorigen Beispiel}
%{{{
\subsubsection{\fachb{Fluid}}
%{{{
Ein Objekt, das wie in Abbildung~\ref{fig:becken-def} als ">Fluid"<
definiert ist, bietet zusätzlich folgende Optionen:

\itA
	\item ">\textbf{Fill ratio}"< in den Richtungen $X$, $Y$ und $Z$:
	Hiermit kann angegeben, wie ">voll"< ein Objekt ist. Hat man
	beispielsweise einen hohen Zylinder zum Fluid-Objekt deklariert und
	möchte diesen aber nur zur Hälfte mit Wasser gefüllt haben, dann
	muss ">X fill ratio"< auf ">0.5"< gesetzt werden. Der Wertebereich
	geht hier von ">0"< bis ">1"<.

	\item ">\textbf{Initial v}"< steht für ">initial velocity"<,
	bestimmt also die Anfangsgeschwindigkeit, und auch hier gibt es
	wieder separate Werte für die Richtungen $X$, $Y$ und $Z$. Möchte
	man also, dass der Wasserblock zu Beginn erst eine Sekunde nach oben
	fliegt und dann wieder herunterfällt, so muss man ">Initial vy"< auf
	">9.81"< setzen. Der Wertebereich ist beliebig, es können also auch
	negative Zahlen eingegeben werden.

	\item ">\textbf{Dither ratio}"<: Hiermit ist es möglich, die
	Flüssigkeit am Anfang etwas durcheinanderzuwirbeln -- aber ohne
	Anfangsgeschwindigkeiten zu setzen. Auch hier ist der Wertebereich
	quasi beliebig, man muss aber bedenken, dass Partikel niemals
	außerhalb des Fluid-Objektes platziert werden. Setzt man ">dither
	ratio"< also zum Beispiel auf ">1000"<, dann wird vermutlich gar
	keine Flüssigkeit mehr erscheinen. Im Bereich ">1 bis 5"< fährt man
	aber ganz gut.

\itE
%}}}

\subsubsection{\fachb{Boundary}}
%{{{
\fachb{Boundaries} sind etwas komplexere Objekte. Gehen wir der Reihe
nach durch:

\itA
	\item ">\textbf{Is static}"<: Von dieser Eigenschaft werden wir
	später im Animationskapitel noch Gebrauch machen. Sie bestimmt, ob
	sich dieses Objekt bewegt oder nicht.

	\item ">\textbf{Is PolyBoundary}"<: Bestimmt, ob die Flächen des
	Körpers als Grenzen angesehen werden sollen oder ob die alte
	vertexbasierte Methode angewandt werden soll. In der Regel will man
	diesen Haken nicht entfernen und schätzungsweise wird diese
	veraltete Option auch bald verschwinden.

	\item ">\textbf{Calculate boundary outside poly(gon)}"<: Da jedes
	Hindernis ein Mesh ist, besteht es zwangsläufig aus einer Menge von
	Polygonen, bei einem \TriMesh sind das lauter Dreiecke. Ein Schritt
	zur Erkennung, ob ein Partikel mit einem Hindernis kollidiert oder
	ihm nahe ist, ist, dieses Partikel in die Ebene zu projizieren, die
	von einem solchen Dreieck aufgespannt wird. Danach wird geprüft, ob
	diese Projektion innerhalb des Dreiecks liegt oder nicht. Somit
	kann, ganz grob umrissen, ein Kollisionstest eines Partikels mit
	einem Dreieck durchgeführt werden. Abbildung~\ref{fig:projektion}
	soll diese Idee noch einmal illustrieren.

	\fpic{gfx/skizzen/projektion.pdf}{fig:projektion}
	{Die Projektionen zweier Kugeln in die Ebene eines Dreiecks. Die
	Projektion der orangenen Kugel liegt nun innerhalb dieses Dreiecks,
	aber die der grünen Kugel nicht -- sie würde also niemals mit dem
	Dreieck kollidieren können, auch wenn sie nicht so hoch über ihm
	stehen würde.}

	Bei manchen Körpern kann bei dieser Methode das Problem auftreten,
	dass Flüssigkeit ">ausläuft"<, das Hindernis also nicht ganz dicht
	ist. Die hier angesprochene Option versucht, dieses Problem zu
	entschärfen. Sie sorgt dafür, dass die Kraft, die auf ein Partikel
	wirkt, wenn seine Projektion in die Ebene außerhalb des Dreiecks
	ist, nicht abrupt Null wird. Stattdessen wirkt auch außerhalb eine
	geringe Kraft auf das Partikel, sofern es in der Nähe ist. Hierfür
	wird der Abstand zum nächstliegenden Punkt im fraglichen Polygon als
	Maß genommen, wie Abbildung~\ref{fig:projektion2} verdeutlichen
	soll.

	\fpic{gfx/skizzen/projektion2.pdf}{fig:projektion2}
	{Auch Partikel, deren Projektion außerhalb eines Polygons liegt,
	erfahren anhand des Abstands zum nächstliegenden Punkt auf dem
	Polygon eine entsprechende Abstoßung, wenn ">Calculate boundary
	outside poly"< aktiviert ist.}

	Diese Lösung ist allerdings nicht perfekt. Außerdem sorgt sie dafür,
	dass häufig ein zu großer Abstand zwischen Hindernis und Flüssigkeit
	herrscht -- was natürlich nicht realistisch ist. Die Option ist
	daher auch standardmäßig deaktiviert. Hat man ein ">Leck"<, kann es
	sich aber unter Umständen lohnen, sie testweise zu aktivieren.

	\item ">\textbf{Velocity Bias}"<: Ein alternatives Gegenmittel gegen
	dasselbe Problem (leckende Körper). Hierbei wird aktiv Energie in
	das System gebracht und Partikel in der Nähe stärker abgestoßen. Der
	eingegebene Wert regelt dabei die Stärke dieser zusätzlichen
	Abstoßung. Dies sollte nur benutzt werden, wenn ">Calculate boundary
	outside poly"< \emph{deaktiviert} ist.

	Damit wird natürlich der Energieerhaltungssatz verletzt. Das führt
	dazu, dass Flüssigkeiten anfangen zu ">kochen"<. Will man also ein
	Leck stopfen, kann diese Option nur mit einem sehr geringen Wert
	eventuell eine Lösung sein. Andererseits kann es aber natürlich auch
	sein, dass man gerade den Effekt des Kochens erzeugen möchte. :-)

	Zu hoch sollte dieser Wert aber nicht sein. Bereits bei ">2"< kann
	es schnell passieren, dass sich die Simulation zu sehr aufschaukelt
	und ">explodiert"<.

	\item ">\textbf{Boundary Factor}"<: Dieser Faktor nimmt Einfluss auf
	das Abprallverhalten von Partikeln und liefert damit in gewissem
	Rahmen eine weitere Alternative, um Lecks entgegenzuwirken. Anders
	als der ">Velocity Bias"< wird hier aber nicht konstant Energie in
	das System gebracht, sondern nur im Kontaktmoment.

	Je höher dieser Faktor ist, desto stärker prallen Partikel von der
	Oberfläche ab. Aber Vorsicht: Ist der Faktor zu hoch, kann auch
	hiermit die Simulation zur Explosion gebracht werden.

	\item ">\textbf{Boundary Clamp}"< steht in direktem Zusammenhang mit
	dem eben erwähnten ">Boundary Factor"<, er setzt nämlich ein Maximum
	für diesen Faktor. Das heißt, man kann verhindern, dass ein schnell
	auftreffendes Teilchen eine exorbitant hohe Reflexionskraft erfährt.
	Will man dagegen ermöglichen, dass Partikel tatsächlich sehr stark
	abprallen, so muss dieser Wert recht hoch angesetzt werden (im
	Zweifelsfalle auf ">1000"< oder mehr).

	\item ">\textbf{Boundary Friction}"<: Dieser Wert tut genau das, was
	sein Name vermuten lässt -- er steuert die Reibung, die auf dieser
	Oberfläche wirkt. Hierbei gibt es nicht allzu viel zu beachten. Je
	höher dieser Wert, desto größer ist die Reibung. Man muss allerdings
	selbst etwas experimentieren, wenn man gezielt bestimmte Materialien
	simulieren will, denn eine ">echte"< physikalische Bedeutung hat der
	Wert nicht. Das heißt leider auch, dass es im Moment nicht möglich
	ist, Referenzwerte von echten Materialien für die Reibung anzugeben.

\itE
%}}}

%}}}

\subsection{Gezielt Flüssigkeit dazugießen (\fachb{Emitters})}
%{{{
\fachb{Emitters} sind wie Fluids eine Möglichkeit, um Flüssigkeit
entstehen zu lassen. Anders als letztere können Emitters aber eher als
">Wasserhahn"< angesehen werden: Aus ihnen strömt Flüssigkeit mit einer
festen Geschwindigkeit in eine bestimmte Richtung.

Es ist nun so, dass Emitters noch ältere Programmteile sind und daher
vertexbasiert arbeiten.\rand{Normalen} Für uns bedeutet das in erster
Linie, dass wir ein bisschen mehr Arbeit haben und zuerst einen ganz
kurzen Ausflug in die Geometrie machen müssen. Denn vorab muss geklärt
werden, welche Bedeutung ">Normalen"< im Allgemeinen und für die
\fluidsim im Speziellen haben.

\fpic{gfx/shots/Wings-Normalen.png}{fig:normalen1}
{Ein Screenshot aus Wings3D, hier lassen sich die Normalen eines Körpers
direkt anzeigen.}

Abbildung~\ref{fig:normalen1} zeigt einen einfachen Zylinder. Zu sehen
sind als kleine blaue Striche außerdem die Normalen: Die Normale einer
Fläche ist ein Vektor, der senkrecht auf dieser Fläche steht. Allerdings
lassen sich nur auf Dreiecken sinnvoll Flächennormalen definieren, denn
nur bei Dreiecken liegen alle Punkte immer in einer gemeinsamen Ebene.
Ein Quadrat zum Beispiel kann ">in sich gekrümmt"< sein, wodurch nicht
mehr all seine Eckpunkt in einer Ebene liegen -- damit ist keine
eindeutige Flächennormale definierbar.

Wir werden gleich den ersten Emitter erstellen, welcher ein einfaches
\TriMesh sein wird. Wie bereits erwähnt, arbeiten Emitters vertexbasiert.
Das heißt, dass jeder Punkt in unserem \TriMesh Flüssigkeit erzeugen
wird. Doch in welche Richtung? Hier kommen jetzt die Normalen ins Spiel.
Normalen sind zwar eigentlich auf Flächen definiert, lassen sich aber
relativ einfach auf die angrenzenden Punkte übertragen. Man kann die
Normale für einen Punkt zum Beispiel bilden, indem man die Normalen
aller angrenzenden Flächen mittelt. Damit hat man eine ungefähre
Richtung definiert, entlang welcher unser Wasser fließen wird.

\aoi beherrscht Mechanismen, um in einem Mesh Vertexnormalen automatisch
aus Flächennormalen erzeugen zu können. Dafür gibt es verschiedene
Vorgehensweisen, aber nur eine davon garantiert uns maximale Kontrolle:
Wir müssen ein \TriMesh mit ">Shading"< als ">Smoothing Method"<
erstellen.

Der schnellste Weg, das zu tun, ist folgender:
\itA
	\item Wir klicken doppelt auf das \PolyMesh-Icon (sic!) und wählen
	dort als Template ein ">Flat Mesh"< aus. Die Größe setzen wir zum
	Beispiel auf 5x5. Die ">Smoothing Method"< in \emph{diesem} Dialog
	muss noch auf ">None"< gesetzt werden.

	\item Nachdem wir ein solches Objekt erstellt haben, wandeln wir es
	mit einem Rechtsklick in der Objektliste in ein \TriMesh um.

	\item Jetzt können wir unter der Objektliste in den Eigenschaften
	die ">Smoothing Method"< auf ">Shading"< setzen.

	\item Da wir dieses Objekt gleich als Emitter setzen wollen, nennen
	wir es auch so: ">Emitter"<.

\itE

Der Sinn dieses Umwegs ist folgender: Nur Shading errechnet korrekte
Vertexnormalen \emph{ohne} die Geometrie des Körpers zu
verändern.\footnote{Wer sich genauer dafür interessiert, kann sich
einmal die Methode \texttt{getWireframeMesh()} in
\texttt{TriangleMesh.java} des \aoi-Quelltextes ansehen.} Prinzipiell
spräche also nichts dagegen, statt des \TriMesh's ein \PolyMesh zu
verwenden -- leider entstehen bei letzteren manchmal falsch berechnete
Vertexnormalen, was bei \TriMesh's nicht der Fall ist.

Wenn dieses Objekt fertig ist, müssen wir es wieder der \fluidsim
bekanntgeben.\rand{Objekte erstellen} Dazu erstellen wir erst ein
Physik-Objekt um den Emitter herum und öffnen dann seine Eigenschaften.
Wie gehabt wählen wir das Objekt ">Emitter"< in der mittleren Liste aus
und setzen diesmal auch seinen Typ auf ">Emitter"<. Anschließend ein
Klick auf ">Set To Selection"<. Nun werden weitere Optionen sichtbar,
von denen ich im Moment nur eine ansprechen will, den ">Normal factor"<.
Dieser gibt die Anfangsgeschwindigkeit in Richtung der oben besprochenen
Normalen an.  Wenn wir also wollen, dass unser Wasser nicht einfach
geradewegs nach unten fließt, sondern zu Beginn in Richtung der Normalen
strömt (bevor die Gravitation zuschlägt), dann sollten wir diesen Faktor
etwa auf ">5"< setzen.

Um die Szene vor dem Baking jetzt noch ein wenig interessanter zu
gestalten, erstellen wir kurz unterhalb des Emitters noch eine Kugel als
Hindernis. Damit wir diese auch in der \fluidsim nutzen können, müssen
wir sie vorher in ein \TriMesh umwandeln, da das Plugin nicht mit
\aoi-Primitiven zurechtkommt. Anschließend definieren wir dieses Objekt
in der Simulation wie im letzten Abschnitt als ">Boundary"<. Jetzt
können wir wie gehabt das Baking starten, hierfür sollte es genügen, nur
die ersten 3 Sekunden zu simulieren.

Abbildung~\ref{fig:emitter-def} zeigt noch einmal das Setup des Emitters
und Abbildung~\ref{fig:render-emitter1} die fertig gerenderte Szene.

\fpic{gfx/shots/Emitter-Definitionen.png}{fig:emitter-def}
{Beispielhaftes Emitter-Setup zusammen mit einer Kugel als Hindernis.
Die Kugel wurde vorher in ein \TriMesh umgewandelt.}

\fpic{gfx/renders/Emitter1.png}{fig:render-emitter1}
{Die gerenderte Szene mit dem Setup aus
Abbildung~\ref{fig:emitter-def}.}
%}}}

\subsection{Erweiterte Optionen zum vorigen Beispiel}
%{{{
\subsubsection{\fachb{Emitters}}
%{{{
Die erweiterten Optionen für Emitters sind recht überschaubar und
erklären sich auch beinahe von selbst:

\itA
	\item ">\textbf{Negative Emitter}"<: Normale Emitters senden
	Flüssigkeit aus. Möchte man aber gezielt Flüssigkeiten aus der
	Simulation wieder entfernen, so muss man diesen Haken setzen.
	Partikel, die einem negativen Emitter nahe sind, werden schlichtweg
	gelöscht.

	Nicht vergessen: Emitters arbeiten immer vertexbasiert -- so auch
	die negativen ihrer Gattung. Will man also hiermit großflächig
	Teilchen löschen, dann muss das Mesh des negativen Emitters sehr
	fein unterteilt sein.

	\item ">\textbf{Normal Factor}"<: Auf diesen Wert wurde weiter oben
	bereits näher eingegangen. Er regelt die Geschwindigkeit entlang der
	Normalen.

	\item Der ">\textbf{Velocity Factor}"< betrifft nur animierte
	Emitters, genauer gesagt, er betrifft nur bewegte. Die Simulation
	erstellt im Normalfall einfach an den gegenwärtigen Vertexpositionen
	neue Teilchen. Bewegt sich ein Emitter aber, dann ist das nicht
	unbedingt physikalisch korrekt -- wer von einem fahrenden Zug
	abspringt, hat auch nicht sofort eine Geschwindigkeit von ">0"<,
	bloß weil er den Zug verlassen hat.

	Setzt man den Faktor also auf ">2"<, so erhalten die Partikel die
	doppelte Geschwindigkeit des Emitters als Anfangsgeschwindigkeit. In
	der Regel dürfte hier ein Wert von ">1"< gewünscht sein, denn die
	reguläre Anfangsgeschwindigkeit sollte über den ">Normal Factor"<
	gesteuert werden.

	\item ">\textbf{Is static}"< ist wie bei Boundaries nötig, wenn eine
	Animation erstellt werden soll. Ist dieser Haken nicht gesetzt,
	bekommt die \fluidsim nicht mit, dass sich der Emitter bewegt.

	\item ">\textbf{Density Factor}"<: Eine recht selbsterklärende
	Option. Hiermit kann gesteuert werden, wieviel Flüssigkeit aus dem
	Emitter austritt. Je kleiner der Wert (es sind allerdings nur
	positive Werte größer Null erlaubt), desto dünnflüssiger ist der
	Partikelstrom. Es tröpfelt.

\itE
%}}}

%}}}

%}}}


\pagebreak
\section{Simulation deformierbarer Körper}
%{{{
TODO: Benutzung, Feder-Masse-System und so
%}}}


\pagebreak
\section{Globale Optionen}
%{{{

\subsection{\fachb{Previews and Views}}
%{{{
TODO: Grid für den Raytracer und Möglichkeit, IsoSurfaces bei selbigem
auszuschalten
%}}}

\subsection{\fachb{Fluid Params}}
%{{{
TODO
%}}}

%}}}


\pagebreak
\section{Weiterführende Techniken}
%{{{

\subsection{\fachb{Baking} fortsetzen}
%{{{
TODO: Wie das überhaupt geht, dabei Parameter ändern
%}}}

\subsection{\fachb{Selection Sets} zur Gruppierung}
%{{{
Mit Version~0.6.6 der \fluidsim wurde eine Integration mit dem
Selections-Plugin von \aoi geschaffen. Das ist insofern eine große
Vereinfachung, als damit massenhaft Objekten Werte zugeordnet werden
können. Außerdem wird die Übersicht erheblich erhöht. Daher lohnt es
sich, einen kurzen Blick auf dieses Plugin zu werfen. Falls es noch
nicht installiert ist, kann es über den Scripts and Plugins Manager
leicht nachinstalliert werden.

Die Grundidee des Selections-Plugins ist es, Objekte in logischen
Gruppen zusammenzufassen. Es kann noch ein bisschen mehr, zum Beispiel
Locking oder Ausblenden der Objekte, die für unseren Zweck aber nicht
ganz so interessant sind -- und überdies selbst\-er\-klä\-rend.

Die Bedienung ist recht einfach: Die Objekte, die man zusammenfassen
will, markiert man und klickt dann unter ">Selections"< auf ">New"<. Das
erstellt eine neue Gruppe, die automatisch all diese Objekte enthält. Da
jedoch nicht ganz offensichtlich ist, dass dies der Fall ist, kann mit
einem Doppelklick auf den Namen des Selection Sets ein neues
Dialogfenster mit einer Übersicht öffnen. In diesem neuen Dialog können
auch Objekte aus der Gruppe herausgenommen werden. Genauer gesagt: Was
hier markiert ist, gehört zur Gruppe.

Ein möglicher Anwendungsfall: Man hat sehr viele Kisten und möchte diese
später alle auf die gleiche Weise als Soft Body verwenden. Dazu fasst
man sie vorab zu einem Selection Set zusammen.

TODO: Explizites Beispiel
%}}}

\subsection{Texturieren, Materialien und Rendern}
%{{{
TODO: Tex/Mat klar, Raster-Renderer empfehlen
%}}}

\subsection{Animation}
%{{{
TODO: Kurzer Abriss, Parameter, Geschwindigkeiten nicht zu hoch, ...
%}}}

%}}}


\pagebreak
\section{Referenzen}
%{{{
TODO: Kurze Übersichten der Schritte, um XYZ zu erledigen -- ohne
Erklärungen oder Screenshots. Zum Nachschlagen.
%}}}


\end{document}


% vim: set tw=72 foldmethod=marker :
