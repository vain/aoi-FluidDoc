% Präambel
%{{{
% Basics
\documentclass[10pt,DIV=14,a4paper]{scrartcl}
\usepackage[ngerman]{babel}
\usepackage[utf8x]{inputenc}

% Grundlegende Pakete
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{graphicx}
\usepackage{color}
\usepackage{hyperref}

% Einfache Anpassungen und PDF-Metadaten
\parindent 0em
\parskip 1em
\definecolor{darkblue}{rgb}{0,0,0.5}
\hypersetup{
	pdftitle={Fluid-Simulation 0.6.6},
	pdfauthor={TroY},
	pdfkeywords={AoI, Physics, Fluid},
	%
	colorlinks=true,
	breaklinks=true,
	linkcolor=black,
	menucolor=darkblue,
	urlcolor=darkblue
}


% Meine sonstigen Sachen
\input{shortcuts}
\input{listings}
\input{pagestyle}

% Befehle nur für dieses Dokument
\input{customcommands}
%}}}


\begin{document}


% Titelseite mit Copyleft
%{{{
\author{TroY}
\title{\fluidsim 0.6.6 \\ mit Art of Illusion}
\date{April/Mai 2009}
\maketitle
\thispagestyle{empty}

\vspace{120mm}

\begin{center}
	\url{http://www.uninformativ.de} \\
	\url{http://www.aoi-board.de}

	Dieses Dokument steht unter der \\
	\textit{Creative Commons Attribution-Noncommercial-Share Alike 3.0 Germany License}, \\
	\url{http://creativecommons.org/licenses/by-nc-sa/3.0/de/}.

	\includegraphics[scale=0.5]{gfx/cc.pdf} \\
	\url{http://creativecommons.org/}
\end{center}

\pagebreak
%}}}

% Inhaltsverzeichnis
%{{{
\tableofcontents
\thispagestyle{empty}
\pagebreak
%}}}


% Dokument
\section{Einleitung}
%{{{

%{{{
Bereits seit 2005 arbeitet \deltor an einem Plugin zur Physiksimulation,
was zu Beginn ein reines Plugin für \blender werden sollte. Er entdeckte
dann zwar recht bald, dass in dieser Hinsicht bereits andere
Programmierer an der Arbeit waren, entschied sich aber trotzdem dafür,
sein eigenes Plugin weiterzuentwickeln -- zum Vorteil für die Nutzer von
\aoi. Denn auf unser schönes Programm stieß \deltor erst Anfang 2007.
Der Kern seiner Simulation war seit jeher in Java geschrieben, was der
Integration mit \aoi natürlich sehr entgegen kam. So nahmen die Dinge
dann ihren Lauf.

\deltor's Plugin ist zwar immernoch in einer recht frühen
Entwicklungsphase, aber es ist durchaus schon zu gebrauchen -- und sei
es nur, um Spaß zu haben. Die jeweils aktuelle Version ist in seinem
Blog verlinkt:

\url{http://delt0r.blogspot.com/}

Da es an Dokumentation jedoch ein bisschen mangelt, die Informationen in
Foren verstreut sind und nicht jeder die Zeit hat, sich mittels ">Trial
and Error"< einzuarbeiten, entstand dieser Guide, um den Einstieg etwas
zu erleichtern. Eigentlich ist das schon die zweite Anleitung dieser
Art, denn bereits von eineinhalb Jahren habe ich eine solche
geschrieben. Bis vor kurzem war sie noch zu gebrauchen, aber Anfang
April 2009 gab es dann einen etwas größeren Sprung in der Entwicklung,
sodass spätestens jetzt eine Aktualisierung notwendig wurde.

Es sei angemerkt, dass dies keine offizielle Dokumentation ist. Dennoch
will ich versuchen, die Vorgänge so genau wie möglich darzustellen und
auf möglichst alle Optionen einzugehen.
%}}}

\subsection{Installation}
%{{{
Die Installation gestaltet sich denkbar einfach: Man besucht \deltor's
Blog, sucht den jeweils aktuellen Link und lädt eine Datei namens
\texttt{Physics.jar} herunter. Diese Datei muss dann in den Unterordner
\texttt{Plugins} des \aoi-Verzeichnisses kopiert werden. Fertig.

Um die Version~0.6.6 nutzen zu können, sollte man am besten \aoi
in der Version~2.7.2 verwenden. Für den Fall, dass \aoi noch gar nicht
installiert ist, kann man es sich unter folgender URL herunterladen:

\url{http://www.artofillusion.org}
%}}}

\subsection{Funktion und Einsatzzweck der Simulation}
%{{{
Wie der Name schon vermuten lässt, ist der primäre Zweck, Flüssigkeiten
zu simulieren. Diese entstehen in einem sogenannten \fachb{Emitter} und
interagieren dann mit als \fachb{Boundary} definierten Objekten in der
Szene.\footnote{Dem Plugin fehlt noch eine deutsche Übersetzung, daher
werde ich mich hier an die englischen Begriffe halten, um Verwirrung zu
vermeiden. Sollte der eine oder andere Begriff Probleme bereiten, dann
findet sich hier ein erstklassiges Online-Wörterbuch:
\url{http://dict.leo.org}} Alternativ kann man auch ganze Objekte als
\fachb{Fluid} vordefinieren, um auf einen Schlag viel Flüssigkeit in die
Szene zu bringen.

Mittlerweile beherrscht das Plugin jedoch auch die Simulation
sogenannter \fachb{Soft Bodies}. Damit sind Körper gemeint, die im
Wesentlichen deformierbar sind, also zum Beispiel Gummibälle oder
Textilien. Man kann damit in gewissem Rahmen zwar auch feste Körper
simulieren, stößt aber bald an die Grenzen. Die Gründe dafür werden
später näher erläutert. Eine richtige Simulation starrer Körper
(\fachb{Rigid Bodies}) wird es erst in Zukunft geben.

Das Plugin ist dabei auch tatsächlich eine \emph{Simulation}. Leider
steht das in einem gewissen Widerspruch zu dem ">Art"< in \aoi.
Simulationen versuchen, der Realität ähnlich zu sein, was zur Folge hat,
dass man sie nur sehr schwer kontrollieren kann. Es ist beispielsweise
nicht einfach, ein fertiges Bild, das das Anstoßen zweier Bierkrüge,
wobei der Inhalt des einen in den anderen überschwappt, mit der
\fluidsim ">mal eben"< etwas aufzupeppen. Stattdessen muss eine
Animation erstellt werden, welche die Bierkrüge im Vorfeld genau so
bewegt, dass die in ihnen enthaltene Flüssigkeit dann auch tatsächlich
im richtigen Moment ">schwappt"<.  Das ist nicht einfach, da sich die
Flüssigkeit realitätsgetreu verhält und man die Krüge nicht mit den
Händen \emph{anfassen} kann. Dadurch wird das Einschätzen der
vorhandenen Massen und wirkenden Kräfte zu keiner leichten Aufgabe.

Auf der anderen Seite ist aber genau das die Herausforderung.

Abgesehen von den künstlerischen Aspekten bietet die Simulation
natürlich eine großartige Spielwiese. Es macht einfach Spaß, einen Turm
aus Kisten zu bauen und dann zuzusehen, wie dieser durch Wasser
weggespült wird. Oder die Simulation einer Kegelbahn. Oder nachgebildete
Hydraulik, die vielleicht sogar einem kleinen Roboter Leben einhaucht.
Oder die realitätsgetreue Darstellung von Kleidung und Stoffen.
Zusammen mit \aoi's Fähigkeiten zur Animation bieten sich nahezu
unendliche Möglichkeiten, da hier auch Prozeduren und Skripte genutzt
werden können.

In diesem Sinne: Viel Spaß!
%}}}

%}}}


\pagebreak
\section{Grundlagen}
%{{{

\subsection{Animationen und \fachb{Baking}}
%{{{
In der Einleitung fiel bereits das entscheidende Stichwort: Animation.
Die \fluidsim beschreibt Vorgänge, die sich zusammen mit der Zeit
verändern. Man kommt also nicht umhin, eine Animation zu erstellen --
auch, wenn man am Ende nur ein einzelnes Bild rendern möchte. Das wäre
zwar nicht allzu viel Arbeit (Animation ist schließlich eine der
Hauptaufgaben von \aoi), aber die \fluidsim nimmt sie uns großteils
sogar ab. Das Minimum ist jedoch, sich die \emph{Zeitleiste} zugänglich
zu machen. Im Normalfall muss man dazu nichts weiter tun, als den Rand
am unteren Ende des \aoi-Hauptfensters mit der Maus ein Stück nach oben
zu ziehen. Mit dieser Leiste ist es möglich, innerhalb einer Animation
zu navigieren.

\fpic{gfx/shots/TimeScore.png}{fig:timescore}
{\aoi mit sichtbarer Zeitleiste. An der orange markierten Stelle muss
gezogen werden, der grüne Schieber dient zum Setzen des Zeitpunktes.}

Da die Berechnungen, welche die \fluidsim anstellt, ziemlich aufwändig
sind, können sie nicht in Echtzeit erfolgen. Die Simulation muss also
vor dem eigentlichen Rendern vorberechnet werden. Dieser Vorgang wird
\fachb{Baking} genannt und wird aus dem Plugin heraus angestoßen. Erst
hiernach hat es auch wirklich eine Auswirkung, wenn man den aktuellen
Zeitpunkt in der Zeitleiste verändert, und die Objekte bewegen sich.

Die Daten werden dabei in einer Datei zwischengespeichert. Man sollte
hier nicht zu geizig sein und sich mit einem fast vollen Datenträger
begnügen: Diese Datei kann bei langen Simulationen mehrere hundert
Megabyte groß werden.
%}}}

\subsection{Zeitschritte und Partikelgrößen}
%{{{
Eine physikalische Simulation läuft am Computer immer ">diskretisiert"<
ab, das heißt, es gibt nur eine endliche Anzahl fester Zeitpunkte, die
berechnet werden. Dazwischen gibt es zwangsweise ">Lücken"<. Daraus
folgt natürlich, dass eine Simulation dann genauer wird, wenn diese
Zeitpunkte näher beeinander liegen. Der Abstand zweier solcher
Zeitpunkte wird im Plugin \fachb{Step Size} genannt.

Man muss hier einen guten Kompromiss finden: Ist die Step Size zu groß,
dann ist die Simulation zwar sehr schnell berechnet, aber höchst
ungenau. Es kann dann passieren, dass Flüssigkeitspartikel ihre
Hindernisse ">überspringen"<. Wird die Step Size dagegen zu klein
gewählt, dauert es einfach zu lange, bis der Baking-Vorgang beendet
ist.\footnote{Eine schöne Anekdote zu diesem Thema findet sich übrigens
hier: \url{http://xkcd.com/505/}}

\fpic{gfx/skizzen/diskrfehler.pdf}{fig:diskrfehler}
{Ein simuliertes Partikel übersieht ein Hindernis durch eine zu große
Step Size.}

Die Flüssigkeiten werden intern als kleine Partikel fester Größe
modelliert, anhand des Parameters \fachb{Particle Size}. Wie man schon
erahnen kann, gilt hier ein ähnlicher Zusammenhang: Sind die Partikel
sehr klein, dann ist die Simulation sehr detailliert, aber langsam. Sind
sie zu groß, simuliert man irgendwann Fußbälle.

Bei beiden Parametern sind Werte voreingestellt, die für einfache
Beispiele ausreichend sind.

Man muss wissen, dass hier ein loser Zusammenhang herrscht. Verringert
man die Partikelgröße, dann sollte man auch die Zeitschritte verringern.
Eine feste Formel hierfür anzugeben, wäre aber nicht sonderlich
praktikabel. Der Grund für diesen Zusammenhang ist, dass kleinere
Partikel noch leichter Hindernisse überspringen oder gegenseitig
ineinander eindringen können, als das bei größeren Partikeln der Fall
ist. Grob lässt sich sagen: Halbiert man die Particle Size, dann sollte
man auch die Step Size halbieren.

\fpic{gfx/skizzen/zshg-groesse-step.pdf}{fig:zshg-groesse-step}
{Bei größeren Partikeln wird noch eine Kollision erkannt, während
kleinere Partikel in derselben Simulation wieder durch das Objekt
tunneln.}

In Abbildung~\ref{fig:zshg-groesse-step} wird auch noch einmal die
grundsätzliche Bedeutung der Step Size deutlich: Auch die großen
Partikel würden durch das Hindernis tunneln, wenn sie sich schneller
bewegen würden. Eine höhere Geschwindigkeit heißt, dass die Partikel pro
Zeitschritt eine größere Distanz zurücklegen, wodurch natürlich die
Lücken zwischen ihnen größer werden. Damit steigt die Chance, dass ein
Teilchen ein Hindernis nicht wahrnimmt. Man muss also auch dann, wenn
man in einer Simulation hohe Geschwindigkeiten hat, eine kleine Step
Size wählen.

In ferner Zukunft soll es dafür eine Lösung geben und zwar eine adaptive
Step Size. Inwiefern das funktionieren und wann es überhaupt eingebaut
wird, ist aber noch offen.
%}}}

%}}}


\pagebreak
\section{Flüssigkeitssimulation}
%{{{

%{{{
Die konkrete Anwendung der \fluidsim erklärt man wohl am besten anhand
eines Beispiels. Im ersten Teil soll unser Ziel sein,
\enumA
	\item ein gefülltes Becken mit Wasser zu erstellen,
	\item Wasser aus einer Quelle herausfließen zu lassen.
\enumE
%}}}

\subsection{Das gefüllte Becken (\fachb{Boundaries} und \fachb{Fluids})}
%{{{
Zuerst werden wir das Becken als Boundary definieren. Seit einiger Zeit
unterstützt das Plugin sogenannte \fachb{Poly Boundaries}, also Objekte,
deren \emph{Flächen} als Hindernis benutzt werden können.\footnote{In
älteren Versionen war das anders. Früher galten die Punkte eines
Objektes als Grenzen, was einiges an Zwischenarbeit erforderte.} Das
heißt für uns, dass wir ganz komfortabel ein \PolyMesh-Objekt in die
Szene bringen und dieses unverändert nutzen können. Tun wir das also und
erstellen uns ein sehr rudimentäres Becken. Um die Übersicht zu wahren,
nennen wir es um in ">Becken"<. Es sollte ungefähr die Maße
$6 \times 6 \times 2$ aufweisen.

Eine kurze Randbemerkung: Primitive \aoi-Objekte, also Würfel, Kugeln
oder Zylinder, können nicht als Hindernisse in der \fluidsim verwendet
werden.

\fpic{gfx/shots/Becken1.png}{fig:becken1}
{Ein einfaches Becken.}

Wie eingangs erwähnt, lassen sich Objekte als Fluid definieren und
werden damit komplett flüssig. Genau das wollen wir jetzt nutzen: Wir
erstellen einen weiteren, einfachen \PolyMesh-Quader, den wir in das
Becken setzen. Noch ist er solide, aber das wird sich bald ändern. Wir
nennen ihn ">Fuellung"<.

\fpic{gfx/shots/Becken2.png}{fig:becken2}
{Das Becken mit (noch) solider Füllung.}

Um Objekten physikalische Eigenschaften zuordnen zu können, muss zuerst
eine Instanz des Fluid-Plugins zur Szene hinzugefügt werden. Man wählt
dazu einfach die blauen Tröpfchen aus der Toolbar aus und zieht ein
Rechteck auf. Was man im nächsten Schritt sieht, ist das Drahtgitter
eines Würfels. Dieser Bereich ist wichtig: Er definiert, wo
Flüssigkeiten existieren können und wo nicht. Verlassen Partikel diesen
Würfel, werden sie automatisch verschwinden. Es ist aber kein Problem,
den Bereich später einfach mit dem gewohnten Skalierungstool zu
erweitern.

Ein Doppelklick auf das neu erstellte Objekt in der Objektliste öffnet
seine Eigenschaften. Hier wird sich nun die ganze Magie abspielen.

Wir markieren das Objekt ">Becken"< in der mittleren
Liste.\rand{Boundary} Um einem Objekt Eigenschaften zuzuweisen, müssen
wir es erst in die aktuelle ">Auswahl"< übernehmen. Die
Begrifflichkeiten kollidieren hier leider etwas, denn diese Auswahl hat
nichts mit den \fachb{Selection Sets} in der linken Hälfte des Dialogs
zu tun -- zu denen kommen wir erst später. Die Auswahl, um die es hier
geht, bestimmt nur jene Objekte, auf die die gesetzten Parameter wirken.
Man könnte in der mittleren Liste also auch mehrere Objekte auf einmal
markieren und diese damit gleichzeitig bearbeiten.

Aus der rechten Dropdown-Liste wählen wir nun ">Boundry"<\footnote{Die
Rechtschreibfehler stehen weiter unten auf der ">TODO"<-Liste...} und
klicken auf ">Set To Selection"<. Es werden jetzt ein paar mehr Optionen
zugänglich, für unser Beispiel sind diese aber optimal.

Als nächstes erklären wir den inneren Quader zur
Flüssigkeit.\rand{Fluid} Auch dieser Vorgang gestaltet sich ziemlich
einfach: Das Objekt namens ">Fuellung"< aus der mittleren Liste wählen,
auf ">Set To Selection"< klicken und diesmal weisen wir ihm den Typ
">Fluid"< zu. Das war's.

\fpic{gfx/shots/Becken-Definitionen.png}{fig:becken-def}
{Die ersten zwei Objekte sind im Plugin definiert.}

Jetzt können wir auch schon den ersten ">Backvorgang"<
starten.\rand{Baking} Dazu wechseln wir auf den Tab ">Baking"<. Hier
kann man einen Zielort für die temporäre Datei angeben, der Standardwert
sollte aber vorübergehend ausreichen. Wichtig ist: Wenn man von vorne
mit der Simulation anfangen will, sollte man immer die beiden Knöpfe
betätigen:

\itA
	\item ">\textbf{Clear Object Cache}"<: Dieser Knopf signalisiert dem
	Plugin, dass es bitte alle zwischengespeicherten Informationen über
	die vorhandenen Objekte vergessen möge, vorallem deren Geometrie.
	Das heißt, diesen Knopf müsste man auch betätigen, wenn man im
	Nachhinein die Größe des Beckens ändern wollte.

	\item ">\textbf{Reset Simulation}"<: Dagegen sorgt dieser zweite
	Knopf dafür, dass sowohl die Zeit auf Null zurückgesetzt als auch
	alle bisher berechneten Bewegungen gelöscht werden. Das muss man
	also zusätzlich auslösen, wenn man sicherstellen will, dass die
	Simulation auch wirklich von vorne anfängt zu rechnen.

\itE

Im unteren Feld können wir noch eingeben, zu welchem Zeitpunkt die
Simulation enden soll. Dieser Zeitpunkt ist \emph{absolut}, das heißt,
er bestimmt \emph{nicht die Dauer} der Simulation. Wir schreiben also
eine ">2"< in das Feld, da wir von Sekunde 0 bis Sekunde 2 simulieren
wollen.

Nach einem Klick auf ">Bake"< erscheint ein Fortschrittsbalken, der aber
bald wieder verschwindet. Verlässt man nun das Plugin mit einem Klick
auf ">OK"< und bewegt danach den Schieber in der Zeitleiste etwas,
sollte man auch schon die ersten Anzeichen von Leben in der Flüssigkeit
entdecken können.

Bevor man ein halbwegs sinnvolles Bild rendern kann, heißt es jedoch:

\itA
	\item Licht muss in die Szene. Dieser Schritt ist trivial und zur
	Not schlage man im Handbuch\footnote{Hier die deutsche Übersetzung
	von Vidiot: \\
	\url{http://www.uninformativ.de/tutorials/Vidiot/AoI_Manual_2_6_ger/contents_de.html}}
	nach. ;-)

	\item Man will vermutlich das \PolyMesh-Objekt ">Fuellung"<
	verstecken. Der Grund dafür ist, dass das Setzen des Objektes auf
	">Fluid"< das originale Objekt nicht beeinflusst. Es dient quasi nur
	als Partikelquelle und ist daher im Normalfall im Weg.

	Keine Sorge, die Flüssigkeit wird dadurch nicht unsichtbar, denn
	diese ist Teil des Objektes ">PhysicsObject 1"<. Würde man also
	tatsächlich die Flüssigkeit \emph{nicht} rendern wollen, so müsste
	man das gesamte Physik-Objekt verstecken. Im Moment ist es noch
	nicht möglich, nur einzelne Teile des Physik-Objektes zu verstecken.

\itE

Abbildung~\ref{fig:render-becken1} zeigt dann, wie ein mögliches
Ergebnis aussehen kann.

\fpic{gfx/renders/Becken1.png}{fig:render-becken1}
{Ein erster Testrender der Szene mit transparentem Hintergrund.}
%}}}

\subsection{Erweiterte Optionen zum vorigen Beispiel}
%{{{
\subsubsection{\fachb{Fluid}}
%{{{
Ein Objekt, das wie in Abbildung~\ref{fig:becken-def} als ">Fluid"<
definiert ist, bietet zusätzlich folgende Optionen:

\itA
	\item ">\textbf{Fill ratio}"< in den Richtungen $X$, $Y$ und $Z$:
	Hiermit kann angegeben, wie ">voll"< ein Objekt ist. Hat man
	beispielsweise einen hohen Zylinder zum Fluid-Objekt deklariert und
	möchte diesen aber nur zur Hälfte mit Wasser gefüllt haben, dann
	muss ">X fill ratio"< auf ">0.5"< gesetzt werden. Der Wertebereich
	geht hier von ">0"< bis ">1"<.

	\item ">\textbf{Initial v}"< steht für ">initial velocity"<,
	bestimmt also die Anfangsgeschwindigkeit, und auch hier gibt es
	wieder separate Werte für die Richtungen $X$, $Y$ und $Z$. Möchte
	man also, dass der Wasserblock zu Beginn erst eine Sekunde nach oben
	fliegt und dann wieder herunterfällt, so muss man ">Initial vy"< auf
	">9.81"< setzen. Der Wertebereich ist beliebig, es können also auch
	negative Zahlen eingegeben werden.

	\item ">\textbf{Dither ratio}"<: Hiermit ist es möglich, die
	Flüssigkeit am Anfang etwas durcheinanderzuwirbeln -- aber ohne
	Anfangsgeschwindigkeiten zu setzen. Auch hier ist der Wertebereich
	quasi beliebig, man muss aber bedenken, dass Partikel niemals
	außerhalb des Fluid-Objektes platziert werden. Setzt man ">dither
	ratio"< also zum Beispiel auf ">1000"<, dann wird vermutlich gar
	keine Flüssigkeit mehr erscheinen. Im Bereich ">1 bis 5"< fährt man
	aber ganz gut.

\itE
%}}}

\subsubsection{\fachb{Boundary}}
%{{{
\fachb{Boundaries} sind etwas komplexere Objekte. Gehen wir der Reihe
nach durch:

\itA
	\item ">\textbf{Is static}"<: Diese Eigenschaft bestimmt, ob ein
	Objekt ">bewegt wird"< oder nicht. Hiermit sind echte Animationen
	gemeint, die man natürlich auch erstellen kann (statt nur
	Einzelbildern). Sobald man manuell, also außerhalb der Simulation
	mittels Keyframes oder prozeduralen Tracks, Objekte bewegt, muss
	dieser Haken unbedingt gesetzt werden. Sonst bekommt die \fluidsim
	davon nichts mit.

	Für mehr Details zu Animationen generell sei noch einmal auf das
	Handbuch verwiesen:

	\url{http://www.uninformativ.de/tutorials/Vidiot/AoI_Manual_2_6_ger/animation_de.html}

	\item ">\textbf{Is PolyBoundary}"<: Bestimmt, ob die Flächen des
	Körpers als Grenzen angesehen werden sollen oder ob die alte
	vertexbasierte Methode angewandt werden soll. In der Regel will man
	diesen Haken nicht entfernen und schätzungsweise wird diese
	veraltete Option auch bald verschwinden.

	\item ">\textbf{Calculate boundary outside poly(gon)}"<: Da jedes
	Hindernis ein Mesh ist, besteht es zwangsläufig aus einer Menge von
	Polygonen, bei einem \TriMesh sind das lauter Dreiecke. Ein Schritt
	zur Erkennung, ob ein Partikel mit einem Hindernis kollidiert oder
	ihm nahe ist, ist, dieses Partikel in die Ebene zu projizieren, die
	von einem solchen Dreieck aufgespannt wird. Danach wird geprüft, ob
	diese Projektion innerhalb des Dreiecks liegt oder nicht. Somit
	kann, ganz grob umrissen, ein Kollisionstest eines Partikels mit
	einem Dreieck durchgeführt werden. Abbildung~\ref{fig:projektion}
	soll diese Idee noch einmal illustrieren.

	\fpic{gfx/skizzen/projektion.pdf}{fig:projektion}
	{Die Projektionen zweier Kugeln in die Ebene eines Dreiecks. Die
	Projektion der orangenen Kugel liegt nun innerhalb dieses Dreiecks,
	aber die der grünen Kugel nicht -- sie würde also niemals mit dem
	Dreieck kollidieren können, auch wenn sie nicht so hoch über ihm
	stehen würde.}

	Bei manchen Körpern kann bei dieser Methode das Problem auftreten,
	dass Flüssigkeit ">ausläuft"<, das Hindernis also nicht ganz dicht
	ist. Die hier angesprochene Option versucht, dieses Problem zu
	entschärfen. Sie sorgt dafür, dass die Kraft, die auf ein Partikel
	wirkt, wenn seine Projektion in die Ebene außerhalb des Dreiecks
	ist, nicht abrupt Null wird. Stattdessen wirkt auch außerhalb eine
	geringe Kraft auf das Partikel, sofern es in der Nähe ist. Hierfür
	wird der Abstand zum nächstliegenden Punkt im fraglichen Polygon als
	Maß genommen, wie Abbildung~\ref{fig:projektion2} verdeutlichen
	soll.

	\fpic{gfx/skizzen/projektion2.pdf}{fig:projektion2}
	{Auch Partikel, deren Projektion außerhalb eines Polygons liegt,
	erfahren anhand des Abstands zum nächstliegenden Punkt auf dem
	Polygon eine entsprechende Abstoßung, wenn ">Calculate boundary
	outside poly"< aktiviert ist.}

	Diese Lösung ist allerdings nicht perfekt. Außerdem sorgt sie dafür,
	dass häufig ein zu großer Abstand zwischen Hindernis und Flüssigkeit
	herrscht -- was natürlich nicht realistisch ist. Die Option ist
	daher auch standardmäßig deaktiviert. Hat man ein ">Leck"<, kann es
	sich aber unter Umständen lohnen, sie testweise zu aktivieren.

	\item ">\textbf{Velocity Bias}"<: Ein alternatives Gegenmittel gegen
	dasselbe Problem (leckende Körper). Hierbei wird aktiv Energie in
	das System gebracht und Partikel in der Nähe stärker abgestoßen. Der
	eingegebene Wert regelt dabei die Stärke dieser zusätzlichen
	Abstoßung. Dies sollte nur benutzt werden, wenn ">Calculate boundary
	outside poly"< \emph{deaktiviert} ist.

	Damit wird natürlich der Energieerhaltungssatz verletzt. Das führt
	dazu, dass Flüssigkeiten anfangen zu ">kochen"<. Will man also ein
	Leck stopfen, kann diese Option nur mit einem sehr geringen Wert
	eventuell eine Lösung sein. Andererseits kann es aber natürlich auch
	sein, dass man gerade den Effekt des Kochens erzeugen möchte. :-)

	Zu hoch sollte dieser Wert aber nicht sein. Bereits bei ">2"< kann
	es schnell passieren, dass sich die Simulation zu sehr aufschaukelt
	und ">explodiert"<.

	\item ">\textbf{Boundary Factor}"<: Dieser Faktor nimmt Einfluss auf
	das Abprallverhalten von Partikeln und liefert damit in gewissem
	Rahmen eine weitere Alternative, um Lecks entgegenzuwirken. Anders
	als der ">Velocity Bias"< wird hier aber nicht konstant Energie in
	das System gebracht, sondern nur im Kontaktmoment.

	Je höher dieser Faktor ist, desto stärker prallen Partikel von der
	Oberfläche ab. Aber Vorsicht: Ist der Faktor zu hoch, kann auch
	hiermit die Simulation zur Explosion gebracht werden.

	\item ">\textbf{Boundary Clamp}"< steht in direktem Zusammenhang mit
	dem eben erwähnten ">Boundary Factor"<, er setzt nämlich ein Maximum
	für diesen Faktor. Das heißt, man kann verhindern, dass ein schnell
	auftreffendes Teilchen eine exorbitant hohe Reflexionskraft erfährt.
	Will man dagegen ermöglichen, dass Partikel tatsächlich sehr stark
	abprallen, so muss dieser Wert recht hoch angesetzt werden (im
	Zweifelsfalle auf ">1000"< oder mehr).

	\item ">\textbf{Boundary Friction}"<: Dieser Wert tut genau das, was
	sein Name vermuten lässt -- er steuert die Reibung, die auf dieser
	Oberfläche wirkt. Hierbei gibt es nicht allzu viel zu beachten. Je
	höher dieser Wert, desto größer ist die Reibung. Man muss allerdings
	selbst etwas experimentieren, wenn man gezielt bestimmte Materialien
	simulieren will, denn eine ">echte"< physikalische Bedeutung hat der
	Wert nicht. Das heißt leider auch, dass es im Moment nicht möglich
	ist, Referenzwerte von echten Materialien für die Reibung anzugeben.

\itE
%}}}

%}}}

\subsection{Gezielt Flüssigkeit dazugießen (\fachb{Emitter})}
%{{{
Ein \fachb{Emitter} ist wie ein Fluid eine Möglichkeit, um Flüssigkeit
entstehen zu lassen. Ein Emitter kann aber eher als ">Wasserhahn"<
angesehen werden: Aus ihnen strömt Flüssigkeit mit einer festen
Geschwindigkeit in eine bestimmte Richtung.

Es ist nun so, dass Emitter noch ältere Programmteile sind und daher
vertexbasiert arbeiten.\rand{Normalen} Für uns bedeutet das in erster
Linie, dass wir ein bisschen mehr Arbeit haben und zuerst einen ganz
kurzen Ausflug in die Geometrie machen müssen. Denn vorab muss geklärt
werden, welche Bedeutung ">Normalen"< im Allgemeinen und für die
\fluidsim im Speziellen haben.

\fpic{gfx/shots/Wings-Normalen.png}{fig:normalen1}
{Ein Screenshot aus Wings3D, hier lassen sich die Normalen eines Körpers
direkt anzeigen.}

Abbildung~\ref{fig:normalen1} zeigt einen einfachen Zylinder. Zu sehen
sind als kleine blaue Striche außerdem die Normalen: Die Normale einer
Fläche ist ein Vektor, der senkrecht auf dieser Fläche steht. Allerdings
lassen sich nur auf Dreiecken sinnvoll Flächennormalen definieren, denn
nur bei Dreiecken liegen alle Punkte immer in einer gemeinsamen Ebene.
Ein Quadrat zum Beispiel kann ">in sich gekrümmt"< sein, wodurch nicht
mehr all seine Eckpunkt in einer Ebene liegen -- damit ist keine
eindeutige Flächennormale definierbar.

Wir werden gleich den ersten Emitter erstellen, welcher ein einfaches
\TriMesh sein wird. Wie bereits erwähnt, arbeiten Emitter vertexbasiert.
Das heißt, dass jeder Punkt in unserem \TriMesh Flüssigkeit erzeugen
wird. Doch in welche Richtung? Hier kommen jetzt die Normalen ins Spiel.
Normalen sind zwar eigentlich auf Flächen definiert, lassen sich aber
relativ einfach auf die angrenzenden Punkte übertragen. Man kann die
Normale für einen Punkt zum Beispiel bilden, indem man die Normalen
aller angrenzenden Flächen mittelt. Damit hat man eine ungefähre
Richtung definiert, entlang welcher unser Wasser fließen wird.

\aoi beherrscht Mechanismen, um in einem Mesh Vertexnormalen automatisch
aus Flächennormalen erzeugen zu können. Dafür gibt es verschiedene
Vorgehensweisen, aber nur eine davon garantiert uns maximale Kontrolle:
Wir müssen ein \TriMesh mit ">Shading"< als ">Smoothing Method"<
erstellen.

Der schnellste Weg, das zu tun, ist folgender:
\itA
	\item Wir klicken doppelt auf das \PolyMesh-Icon (sic!) und wählen
	dort als Template ein ">Flat Mesh"< aus. Die Größe setzen wir hier
	zum Beispiel auf $5 \times 5$, das erstellte Objekt sollte dann etwa
	die Ausdehnung $4 \times 4$ in AoI-Einheiten besitzen. Die
	">Smoothing Method"< in \emph{diesem} Dialog muss noch auf ">None"<
	gesetzt werden.

	\item Nachdem wir ein solches Objekt erstellt haben, wandeln wir es
	mit einem Rechtsklick in der Objektliste in ein \TriMesh um.

	\item Jetzt können wir unter der Objektliste in den Eigenschaften
	die ">Smoothing Method"< auf ">Shading"< setzen.

	\item Da wir dieses Objekt gleich als Emitter setzen wollen, nennen
	wir es auch so: ">Emitter"<.

\itE

Der Sinn dieses Umwegs ist folgender: Nur Shading errechnet korrekte
Vertexnormalen \emph{ohne} die Geometrie des Körpers zu
verändern.\footnote{Wer sich genauer dafür interessiert, kann sich
einmal die Methode \texttt{getWireframeMesh()} in
\texttt{TriangleMesh.java} des \aoi-Quelltextes ansehen.} Prinzipiell
spräche also nichts dagegen, statt des \TriMesh's ein \PolyMesh zu
verwenden -- leider entstehen bei letzteren manchmal falsch berechnete
Vertexnormalen, was bei \TriMesh's nicht der Fall ist.

Wenn dieses Objekt fertig ist, müssen wir es wieder der \fluidsim
bekanntgeben.\rand{Objekte erstellen} Dazu erstellen wir erst ein
Physik-Objekt um den Emitter herum und öffnen dann seine Eigenschaften.
Wie gehabt wählen wir das Objekt ">Emitter"< in der mittleren Liste aus
und setzen diesmal auch seinen Typ auf ">Emitter"<. Anschließend ein
Klick auf ">Set To Selection"<. Nun werden weitere Optionen sichtbar,
von denen ich im Moment nur eine ansprechen will, den ">Normal factor"<.
Dieser gibt die Anfangsgeschwindigkeit in Richtung der oben besprochenen
Normalen an.  Wenn wir also wollen, dass unser Wasser nicht einfach
geradewegs nach unten fließt, sondern zu Beginn in Richtung der Normalen
strömt (bevor die Gravitation zuschlägt), dann sollten wir diesen Faktor
etwa auf ">5"< setzen.

Um die Szene vor dem Baking jetzt noch ein wenig interessanter zu
gestalten, erstellen wir kurz unterhalb des Emitters noch eine Kugel als
Hindernis. Damit wir diese auch in der \fluidsim nutzen können, müssen
wir sie vorher in ein \TriMesh umwandeln, da das Plugin nicht mit
\aoi-Primitiven zurechtkommt. Anschließend definieren wir dieses Objekt
in der Simulation wie im letzten Abschnitt als ">Boundary"<. Jetzt
können wir wie gehabt das Baking starten, hierfür sollte es genügen, nur
die ersten 3 Sekunden zu simulieren.

Abbildung~\ref{fig:emitter-def} zeigt noch einmal das Setup des Emitters
und Abbildung~\ref{fig:render-emitter1} die fertig gerenderte Szene.

\fpic{gfx/shots/Emitter-Definitionen.png}{fig:emitter-def}
{Beispielhaftes Emitter-Setup zusammen mit einer Kugel als Hindernis.
Die Kugel wurde vorher in ein \TriMesh umgewandelt.}

\fpic{gfx/renders/Emitter1.png}{fig:render-emitter1}
{Die gerenderte Szene mit dem Setup aus
Abbildung~\ref{fig:emitter-def}.}
%}}}

\subsection{Erweiterte Optionen zum vorigen Beispiel}
%{{{
\subsubsection{\fachb{Emitter}}
%{{{
Die erweiterten Optionen für Emitter sind recht überschaubar und
erklären sich auch beinahe von selbst:

\itA
	\item ">\textbf{Negative Emitter}"<: Normale Emitter senden
	Flüssigkeit aus. Möchte man aber gezielt Flüssigkeiten aus der
	Simulation wieder entfernen, so muss man diesen Haken setzen.
	Partikel, die einem negativen Emitter nahe sind, werden schlichtweg
	gelöscht.

	Nicht vergessen: Emitter arbeiten immer vertexbasiert -- so auch
	die negativen ihrer Gattung. Will man also hiermit großflächig
	Teilchen löschen, dann muss das Mesh des negativen Emitters sehr
	fein unterteilt sein.

	\item ">\textbf{Normal Factor}"<: Auf diesen Wert wurde weiter oben
	bereits näher eingegangen. Er regelt die Geschwindigkeit entlang der
	Normalen.

	\item Der ">\textbf{Velocity Factor}"< betrifft nur animierte
	Emitter, genauer gesagt, er betrifft nur bewegte. Die Simulation
	erstellt im Normalfall einfach an den gegenwärtigen Vertexpositionen
	neue Teilchen. Bewegt sich ein Emitter aber, dann ist das nicht
	unbedingt physikalisch korrekt -- wer von einem fahrenden Zug
	abspringt, hat auch nicht sofort eine Geschwindigkeit von ">0"<,
	bloß weil er den Zug verlassen hat.

	Setzt man den Faktor also auf ">2"<, so erhalten die Partikel die
	doppelte Geschwindigkeit des Emitters als Anfangsgeschwindigkeit. In
	der Regel dürfte hier ein Wert von ">1"< gewünscht sein, denn die
	reguläre Anfangsgeschwindigkeit sollte über den ">Normal Factor"<
	gesteuert werden.

	\item ">\textbf{Is static}"< ist wie bei Boundaries nötig, wenn eine
	Animation erstellt werden soll. Ist dieser Haken nicht gesetzt,
	bekommt die \fluidsim nicht mit, dass sich der Emitter bewegt.

	\item ">\textbf{Density Factor}"<: Eine recht selbsterklärende
	Option. Hiermit kann gesteuert werden, wieviel Flüssigkeit aus dem
	Emitter austritt. Je kleiner der Wert (es sind allerdings nur
	positive Werte größer Null erlaubt), desto dünnflüssiger ist der
	Partikelstrom. Es tröpfelt.

\itE
%}}}

%}}}

%}}}


\pagebreak
\section{Simulation deformierbarer Körper}
%{{{

\subsection{Hintergrund}
%{{{
\fachb{Soft Bodies} werden als sogenannte Feder-Masse-Systeme
modelliert. Das heißt, es gibt mehrere Massepunkte, die durch Federn
verbunden sind. In gewissem Rahmen und mit einer geeigneten Geometrie
können damit weiche, wabernde Körper simuliert werden.

Abbildung~\ref{fig:2dsim} eine einfache, zweidimensionale Version eines
Feder-Masse-Systems: Die grünen Punkte sind bewegliche Massepunkte, der
rote Punkt in der Mitte ist fixiert und die Verbindungen zwischen den
Punkten stellen die eingesetzten Federn dar.

Es gibt zwei dominierende Faktoren, die eine solche Simulation
beeinflussen: Die Federkonstante (\fachb{Spring Constant}) und die Masse
eines Partikels (\fachb{Particle Mass}). In Abbildung~\ref{fig:2dsim}
sind gleich mehrere Simulationen dargestellt, wobei die Federkonstante
variiert. Eine kleinere Konstante sorgt dafür, dass das Objekt
">weicher"< ist -- wird diese Konstante aber zu klein gewählt, dann
bricht das Objekt einfach in sich zusammen.

\fpic{gfx/shots/PSim-montage.png}{fig:2dsim}
{Zweidimensionale Simulation eines Feder-Masse-Systems mit verschiedenen
Federkonstanten (absteigend von links oben nach rechts unten). Ist diese
zu niedrig, bricht das System zusammen. Wäre sie zu hoch, würde es aber
durch numerische Instabilität ">explodieren"<.}

Deklariert man in \aoi ein Objekt als Soft Body, dann werden alle
Punkte des \TriMesh's zu Massepunkten und die Kanten dazwischen zu
Federn. Dabei findet eine gleichmäßige Verteilung statt, also wird allen
Federn dieselbe Konstante und allen Massepunkten dieselbe Masse
zugewiesen.
%}}}

\subsection{Benutzung}
%{{{
Im Folgenden werden wir ein einfaches Szenario simulieren: Zwei leicht
versetzt gegenüberliegende Würfel werden eine Rampe herunterrutschen und
dann kollidieren.

Erstellen wir zuerst die Rampe. Da diese später ein Boundary wird, ist
hierfür ein \PolyMesh-Objekt perfekt geeignet. Wie genau man eine solche
einfache Rampe erstellt, möchte ich hier nicht genauer beschreiben, da
es dafür genügend andere Tutorials gibt.\footnote{Siehe zum Beispiel:
\url{http://www.aoi-board.de/index.php?action=posts&fid=26&tid=16}} In
einer gewissen Höhe darüber erstellen wir dann zwei einfache Würfel, die
wir danach in \TriMesh'es konvertieren (befindet sich der Boden der
Rampe in $Y$-Richtung bei $0$, dann setzen wir die Würfel etwa auf Höhe
$8$). Diese Würfel selbst sollten etwa die Ausdehnung $2 \times 2 \times
2$ in AoI-Einheiten haben. Damit die Körper auch schön ">soft"<
aussehen, setzen wir ihre Smoothing Method auf ">Approximating"< -- und
damit wir sie auch leicht auseinanderhalten können, bekommen sie zwei
unterschiedliche Texturen.  Zuguterletzt drehen wir die beiden noch ganz
leicht, um eine gewisse Anfangsstörung in das System zu bringen (es ist
meistens relativ langweilig, Objekte perfekt nach unten fallen zu
lassen). Abbildung~\ref{fig:rampe1} zeigt ein solches Setup.

\fpic{gfx/shots/Rampe1.png}{fig:rampe1}
{Das fertige Setup mit Rampe und zwei geglätteten Würfeln.}

Wichtig bei Texturen für Soft Bodies: Hier muss unter ">Texture
Mapping"< in den normalen \aoi Optionen unbedingt der Haken ">Bind
Texture Coordinates to Surface"< aktiviert werden, ansonsten verschiebt
sich später die Textur.\footnote{Die Objekte werden durch die Simulation
in ihrem lokalen Koordinatensystem verschoben.}

Jetzt können wir ein Physik-Objekt in die Szene bringen, das all diese
Objekte umfasst. Dort stellen wir wie gehabt die Rampe auf ">Boundary"<
(um es etwas interessanter zu gestalten, kann hier direkt die Reibung
zum Beispiel auf ">250"< gesetzt werden) und diesmal die beiden Würfel
auf ">Soft"<. An deren Einstellungen ändern wir nur ">Internal Reps"<
auf ">3"<, ansonsten bleibt alles bei den Standardeinstellungen. Jetzt
kann auch schon gebacken werden -- dieser Vorgang sollte in wenigen
Sekunden erledigt sein. Bewegt man hiernach den Zeitschieber, sollten
die beiden Würfel herunterfallen und dann kollidieren -- wie in
Abbildung~\ref{fig:rampe1-montage} zu sehen.

\fpic{gfx/renders/Rampe1-montage.png}{fig:rampe1-montage}
{Die aus Abbildung~\ref{fig:rampe1} entstandene Simulation der zwei
fallenden Würfel.}

Man sollte bei Soft Bodies ein paar Dinge im Kopf behalten:
\itA
	\item Sie sind eigentlich nicht für Objekte wie Würfel gedacht,
	sondern für wirklich weiche Objekte. Wie man sieht, kann man zwar
	mit entsprechend großer Federkonstanten auch scheinbar harte Objekte
	simulieren, diese werden aber immer kollabieren, wenn zu große
	Kräfte auf sie wirken. Man kann sie zum Beispiel nicht aus
	beliebiger Höhe fallenlassen.

	\item Viele Objekte sind nicht stabil -- zum Beispiel ein langes
	Brett. Dieses würde sich eher wie ein Stück Stoff verhalten und
	lasch in sich zusammenfallen. Der Versuch, ein Katapult zu
	simulieren, dürfte also wahrscheinlich fehlschlagen.\footnote{Ich
	würde mich aber sehr über mögliche Lösungen freuen. :-)}

	\item Es gibt noch keine Selbstkollision, ein Soft Body kollidiert
	also nie mit sich selbst. Einerseits begünstigt das leider den
	häufigen Kollaps, andererseits sind dadurch auch Stoffe
	(\fachb{Clothes}) nicht realistisch simulierbar.

	\item Man darf nie vergessen, die Objekte in \TriMesh'es zu
	konvertieren. :-)

\itE
%}}}

\subsection{Erweiterte Optionen}
%{{{
Auch Soft Bodies besitzen ein paar Einstellungen zusätzlich:
\itA
	\item ">\textbf{Spring Constant}"< und ">\textbf{Particle Mass}"<:
	Das sind die zwei Hauptparameter, die auch schon im einleitenden
	Abschnitt angesprochen wurden. Die Federkonstante regelt, wie
	">steif"< die Federn zwischen den Massepunkten sind, und die
	Partikelmasse gibt das Gewicht eines solchen Punktes an.

	Zur Erinnerung: Vertices eines Dreiecksmeshes werden zu Massepunkten
	und die Edges dazwischen zu Federn.

	Man erkennt schnell, dass auch die Federkonstante erhöht werden
	muss, wenn die Masse erhöht wird. Das ist klar, denn die Federn
	müssen dann mehr Gewicht tragen. Über die Masse lassen sich auch
	Kollisionen steuern. Für eine Bowling-Szene muss der Kugel eine
	entsprechend höhere Masse gegeben werden, denkbar wäre das folgende
	Setup:

	\itA
		\item Die Kegel erhalten eine Masse von ">0.5"< mit der
		Standard-Federkonstanten.

		\item Die Bowlingkugel dagegen erhält die Masse ">10.0"< und
		eine Federkonstante von ">10'000"<.
	\itE

	\item ">\textbf{Damping}"<: Fangen die Objekte an zu zittern, kann
	die Dämpfung (der Federn) erhöht werden, um dem entgegenzuwirken.
	Eigentlich ist der vorgegebene Wert ">0.5"< relativ niedrig und
	häufig werden eher ">1"< oder ">2"< benötigt.

	\item ">\textbf{Boundary Force}"<: Treffen zwei Soft Bodies
	aufeinander, erfolgt die Kollisionserkennung nach dem Schema
	">Punkte versus Flächen"<. Das heißt, für alle Punkte eines Soft
	Bodies wird getestet, ob sie die Flächen eines anderen Soft Bodies
	berühren. Wenn ja, dann liegt eine Kollision vor.

	Dabei kann es passieren, dass sich Objekte durchdringen. Die
	Boundary Force ist ein Versuch, diesem Effekt etwas
	entgegenzuwirken.

	\item ">\textbf{Internal Reps}"<: Die Zeitschritte der Simulation
	von Soft Bodies wurden leicht von denen der restlichen Simulation
	entkoppelt. Dieser Faktor regelt, wieviele zusätzliche Zeitpunkte
	für diesen Körper betrachtet werden -- pro globalem Zeitschritt.
	Steht zum Beispiel die globale Step Size auf ">0.01"< und die
	Interal Reps auf ">5"<, läuft das auf eine effektive Step Size von
	">0.002"< hinaus.

	Man sollte diese Funktion aber nur behutsam anwenden. Insbesondere,
	wenn man die Meldung bekommt, man möge für Soft Bodies doch bitte
	die Zeitschritte verringern -- dann löst man das am besten über die
	Internal Reps und lässt die globale Step Size unberührt.

\itE

%}}}

%}}}


\pagebreak
\section{Globale Optionen}
%{{{

\subsection{\fachb{Previews and Views}}
%{{{
Wir gehen kurz die vorhanden Optionen in diesem Tab durch. Es sei darauf
hingewiesen, dass Vidiot eine schöne Übersicht der Ergebnisse bezüglich
der verschiedenen Iso-Surface-Parameter erstellt hat:

\url{http://www.aoi-board.de/index.php?action=redirect&loc=show_post&id=1731}

Aber der Reihe nach:

\itA
	\item ">\textbf{Preview Particles}"<: Soll überhaupt eine Vorschau
	von Partikeln erstellt werden?

	\item ">\textbf{Preview Boundary}"<: Diese Option scheint keinen
	Effekt mehr zu haben.

	\item ">\textbf{Use IsoSurfaces for Raytracing}"<: Iso-Surfaces
	(manchmal auch implizite Flächen, Blobs oder Metaballs genannt --
	auch, wenn nicht alle exakt dasselbe meinen) sind eine grundlegend
	andere Art, um Oberflächen zu beschreiben. Anders als triangulierte
	Meshes, die nur aus Dreiecken bestehen und daher den gewünschten
	Körper oft nur \emph{annähern} können, bieten Iso-Surfaces eine viel
	kompaktere Form der Speicherung und Beschreibung von Objekten. Die
	einfachste Iso-Fläche ist die Kugel:

	\begin{quote}
		"`Alle Punkte im Raum, die den Abstand $5$ vom Mittelpunkt
		besitzen, gehören zur Fläche."'
	\end{quote}

	Damit ist eine Kugeloberfläche mit Radius $5$ mathematisch exakt
	beschrieben -- ein Dreiecksnetz müsste dagegen unendlich viele
	Dreiecke aufweisen, um diese Genauigkeit zu erreichen.

	Natürlich gibt es wie immer Nachteile, denn zum einen benötigt das
	Rendern von Iso-Surfaces mehr Zeit und zum anderen eignen sie sich
	eher schlecht zum allgemeinen Modellieren. Dafür aber umso besser
	zum Rendern von Flüssigkeiten, denn ">triangulierte Flüssigkeiten"<
	würden zwangsläufig ziemlich kantig aussehen. Als Iso-Surfaces
	erscheinen sie dagegen völlig ">smooth"<, da hierfür viele kleine
	Kugeln verwendet werden, die sanft ineinander überfließen.

	Diese Option zu \emph{de}aktivieren, kann aber auch gewünscht sein:
	Dann nämlich rendert \aoi's Raytracer nur noch die
	pyramidenförmigen, spitzen Partikel, wie man sie auch in der
	Vorschau sieht. Das ist natürlich erheblich schneller. Es ist auch
	dringend empfehlenswert, diese Option zu \emph{de}aktivieren, wenn
	man ausschließlich Soft Bodies rendert.

	\item ">\textbf{Metaball size ratio}"<: Werden Iso-Surfaces genutzt,
	regelt diese Option die ">Größe"< der Kugeln. Das ist jedoch nicht
	mit der eigentlichen Particle Size zu verwechseln. Hierbei handelt
	es sich nur um einen reinen Darstellungsparameter -- wird die
	Metaball Size als verkleinert, werden die einzelnen
	Flüssigkeitspartikel zwar kleiner gerendert, aber immernoch so
	berechnet wie vorher. Das Resultat ist unrealistisch.

	\item ">\textbf{Implicit Surface Threshold}"<: Iso-Surfaces werden
	nicht wie gewöhnlich mit direkten Schnitttests (">Schneidet der
	aktuelle Ray ein Dreieck? Wenn ja, wo und wie?"<) gerendert, sondern
	es wird gewöhnlich an einem Ray ">entlanggetastet"<. In der Theorie
	muss der Abstand zwischen zwei Abstandpunkten unendlich klein sein.
	In der Praxis geht das natürlich nicht, also legt man eine bestimmte
	Schrittweite fest, was hiermit getan wird.

	Je größer der Wert ist, desto Schneller ist das Rendern, aber desto
	ungenauer ist das Ergebnis auch. Ein kleinerer Wert, zum Beispiel
	">0.5"< braucht mehr Zeit, sieht aber besser aus.

	\item ">\textbf{Mesh Preview}"< und ">\textbf{Mesh Size}"<: Hiermit
	wird eine Triangulierung der Flüssigkeit vorgenommen und das
	resultierende \TriMesh direkt -- ohne Rendern -- in der Szene
	dargestellt. Dieser Prozess ist allerdings äußerst aufwändig und als
	Vorschau kaum nützlich.

	Die Größe bestimmt die Genauigkeit des Mesh Previews. Je höher der
	Wert ist, desto ungenauer ist das Ergebnis. Achtung: Kleine Werte
	können \aoi schnell in die Knie zwingen, sodass man es nur noch
	abwürgen kann.

	\item ">\textbf{Velocity Factor}"<: Ist Mesh Preview aus (Standard),
	dann werden kleine Pyramiden angezeigt, welche die aktuelle Richtung
	und (in Form ihrer Höhe) Geschwindigkeit eines jeden Partikels
	symbolisieren. Der Velocity Factor regelt nun, wie stark die
	aktuelle Geschwindigkeit in diese Darstellung einfließt -- größere
	Werte bedeuten mehr Einfluss. In der Regel will man hier den
	Standardwert beibehalten.

	\item ">\textbf{Ratio displayed particles}"<: Diese Optionen scheint
	keinen Effekt mehr zu haben.

	\item ">\textbf{Use Sample Grid}"< und ">\textbf{Sample Grid
	Factor}"<: Dies ist eine Option zur Beschleunigung des
	Rendervorgangs, indem der Raum gleichmäßig in ein Gitter unterteilt
	wird. In diesem Gitter werden Ergebnisse des Raytracings
	zwischengespeichert, sodass de facto nicht mehr jeder Ray komplett
	verfolgt wird -- landet er in einem bereits besuchten Gitterknoten,
	erhält er den dort gespeicherten Wert. Dadurch wird das Bild
	natürlich wieder ungenauer und es kann auch zu Artefakten kommen.

	Je kleiner der Wert ist, desto ungenauer ist das Ergebnis. Es lohnt
	sich aber kaum mehr, diese Option zu aktivieren, da das Plugin
	anderweitig über bessere Optimierungen verfügt.

\itE
%}}}

\subsection{\fachb{Fluid Params}}
%{{{
\itA
	\item ">\textbf{Step Size}"<: Bestimmt den zeitlichen Abstand zweier
	Simulationsschritte. Hierauf wurde bereits in den Grundlagen genauer
	eingegangen.

	\item ">\textbf{Frame Bake Size}"<: Hiermit können Frames
	zusammengefasst werden, während die darunterliegende Simulation mit
	derselben Schrittweite berechnet wird. Ein Wert von ">1.0"< bewirkt
	beispielsweise, dass nur noch jede Sekunde ein neuer
	Simulationsschritt sichtbar wird.

	Will man die zeitliche Auflösung erhöhen, also mit mehr Bildern pro
	Sekunde rendern, so muss gegebenenfalls dieser Wert geändert
	werden. Er lässt sich berechnen als
	\aleq
	{
		size &= \frac{1}{fps} \qq ,
	}
	wobei mit $fps$ die gewünschten Bilder pro Sekunde bezeichnet
	werden. Für 200 Bilder pro Sekunde muss dieser Wert also auf $0.005$
	gesetzt werden. Ansonsten wird die Animation ruckeln.
	Selbstverständlich muss eventuell auch die Step Size an sich
	verringert werden.

	\item ">\textbf{Particle Size}"<: Die Größe eines Partikels. Wurde
	auch bei den Grundlagen behandelt.

	\item ">\textbf{Density}"<: Die Dichte oder Kohärenz der
	Flüssigkeit. Wird dieser Wert verringert, so neigt die Simulation
	dazu, einzelne ">Kleckse"< zu produzieren, während sie bei großen
	Werten eher ein zusammengehöriges Gebilde formt.

	\item ">\textbf{Body Acceleration}"<: Hiermit ist schlichtweg die
	Gravitation gemeint. Daher ist die mittlere Erdbeschleunigung in
	negativer $Y$-Richtung auch der Standard.

\itE

%}}}

%}}}


\pagebreak
\section{Weiterführende Techniken}
%{{{

\subsection{\fachb{Baking} fortsetzen}
%{{{
Es ist möglich, das Baking an einem beliebigen Punkt zu unterbrechen.
Aber auch, wenn der Bake-Prozess sein reguläres Ende erreicht, kann man
ihn später an dieser Stelle fortsetzen. Dazu öffnet man einfach die
Einstellungen des Physik-Objektes, wechselt auf den ">Bake"<-Tab und
stellt dort einen Zeitpunkt ein, der in der Zukunft liegt. Die
Simulation setzt dann am aktuellen Zeitpunkt fort.

Auf diesem Weg können auch die Parameter der Simulation ">im laufenden
Betrieb"< geändert werden. Beispielsweise kann zwischendurch ein Emitter
deaktiviert werden -- das ist auch so einfach, wie es klingt, er muss
einfach in den Objektdefinitionen im Tab ">Object Management"< auf
">None"< gesetzt werden.

Zur Sicherheit sollte bei solchen Änderungen aber vor dem Fortsetzen des
Bake-Prozesses der Knopf ">Clear Object Cache"< betätigt werden, damit
auch alle Änderungen übernommen werden. \emph{Nicht} betätigen sollte
man den Knopf ">Reset Simulation"< -- hiermit wird alles zurückgesetzt
und bei Null begonnen.
%}}}

\subsection{\fachb{Selection Sets} zur Gruppierung}
%{{{
Mit Version~0.6.6 der \fluidsim wurde eine Integration mit dem
Selections-Plugin von \aoi geschaffen. Das ist insofern eine große
Vereinfachung, als damit massenhaft Objekten Werte zugeordnet werden
können. Außerdem wird die Übersicht erheblich erhöht. Daher lohnt es
sich, einen kurzen Blick auf dieses Plugin zu werfen. Falls es noch
nicht installiert ist, kann es über den Scripts and Plugins Manager
leicht nachinstalliert werden.

Die Grundidee des Selections-Plugins ist es, Objekte in logischen
Gruppen zusammenzufassen. Es kann noch ein bisschen mehr, zum Beispiel
Locking oder Ausblenden der Objekte, die für unseren Zweck aber nicht
ganz so interessant sind -- und überdies selbst\-er\-klä\-rend.

Die Bedienung ist recht einfach: Die Objekte, die man zusammenfassen
will, markiert man und klickt dann unter ">Selections"< auf ">New"<. Das
erstellt eine neue Gruppe, die automatisch all diese Objekte enthält. Da
jedoch nicht ganz offensichtlich ist, dass dies der Fall ist, kann mit
einem Doppelklick auf den Namen des Selection Sets ein neues
Dialogfenster mit einer Übersicht öffnen. In diesem neuen Dialog können
auch Objekte aus der Gruppe herausgenommen werden. Genauer gesagt: Was
hier markiert ist, gehört zur Gruppe.

Ein möglicher Anwendungsfall: Man hat sehr viele Kegel und möchte diese
später alle auf die gleiche Weise als Soft Body verwenden. Dazu fasst
man sie vorab zu einem Selection Set zusammen. Im Plugin selbst
erscheint dann in der linken Tabelle ein neuer Eintrag. Wählt man diesen
aus, werden automatisch alle Objekte in der Mitte markiert, die zu
diesem Set gehören. Man kann sie nun zur aktuellen Auswahl hinzufügen
und somit ihnen allen auf einen Schlag Eigenschaften geben (siehe
Abbildung~\ref{fig:selsets1}).

\fpic{gfx/shots/SelectionSet1.png}{fig:selsets1}
{Ein Selection Set in der Anwendung. Hier der Zustand, nachdem der Knopf
">Set To Selection"< betätigt wurde.}
%}}}

%}}}


\end{document}


% vim: set tw=72 foldmethod=marker :
