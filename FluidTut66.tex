% Präambel
%{{{
% Basics
\documentclass[10pt,DIV=14,a4paper]{scrartcl}
\usepackage[ngerman]{babel}
\usepackage[utf8x]{inputenc}

% Grundlegende Pakete
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{graphicx}
\usepackage{color}
\usepackage{hyperref}

% Einfache Anpassungen und PDF-Metadaten
\parindent 0em
\parskip 1em
\definecolor{darkblue}{rgb}{0,0,0.5}
\hypersetup{
	pdftitle={Fluid-Simulation 0.6.6},
	pdfauthor={TroY},
	pdfkeywords={AoI, Physics, Fluid},
	%
	colorlinks=true,
	breaklinks=true,
	linkcolor=black,
	menucolor=darkblue,
	urlcolor=darkblue
}


% Meine sonstigen Sachen
\input{shortcuts}
\input{listings}
\input{pagestyle}

% Befehle nur für dieses Dokument
\input{customcommands}
%}}}


\begin{document}


% Titelseite mit Copyleft
%{{{
\author{TroY}
\title{\fluidsim 0.6.6 \\ mit Art of Illusion}
\date{April 2009}
\maketitle
\thispagestyle{empty}

\vspace{120mm}

\begin{center}
	\url{http://www.uninformativ.de} \\
	\url{http://www.aoi-board.de}

	Dieses Dokument steht unter der \\
	\textit{Creative Commons Attribution-Noncommercial-Share Alike 3.0 Germany License}, \\
	\url{http://creativecommons.org/licenses/by-nc-sa/3.0/de/}.

	\includegraphics[scale=0.5]{gfx/cc.pdf} \\
	\url{http://creativecommons.org/}
\end{center}

\pagebreak
%}}}

% Inhaltsverzeichnis
%{{{
\tableofcontents
\thispagestyle{empty}
\pagebreak
%}}}


% Dokument
\section{Einleitung}
%{{{

%{{{
Bereits seit 2005 arbeitet \deltor an einem Plugin zur Physiksimulation,
was zu Beginn ein reines Plugin für \blender werden sollte. Er entdeckte
dann zwar recht bald, dass in dieser Hinsicht bereits andere
Programmierer an der Arbeit waren, entschied sich aber trotzdem dafür,
sein eigenes Plugin weiterzuentwickeln -- zum Vorteil für die Nutzer von
\aoi. Denn auf unser schönes Programm stieß \deltor erst Anfang 2007.
Der Kern seiner Simulation war seit jeher in Java geschrieben, was der
Integration mit \aoi natürlich sehr entgegen kam. So nahmen die Dinge
dann ihren Lauf.

\deltor's Plugin ist zwar immernoch in einer recht frühen
Entwicklungsphase, aber es ist durchaus schon zu gebrauchen -- und sei
es nur, um Spaß zu haben. Die jeweils aktuelle Version ist in seinem
Blog verlinkt:

\url{http://delt0r.blogspot.com/}

Da es an Dokumentation jedoch ein bisschen mangelt, die Informationen in
Foren verstreut sind und nicht jeder die Zeit hat, sich mittels ">Trial
and Error"< einzuarbeiten, entstand dieser Guide, um den Einstieg etwas
zu erleichtern. Eigentlich ist das schon die zweite Anleitung dieser
Art, denn bereits von eineinhalb Jahren habe ich eine solche
geschrieben. Bis vor kurzem war sie noch zu gebrauchen, aber Anfang
April 2009 gab es dann einen etwas größeren Sprung in der Entwicklung,
sodass spätestens jetzt eine Aktualisierung notwendig wurde.

Es sei angemerkt, dass dies keine offizielle Dokumentation ist. Dennoch
will ich versuchen, die Vorgänge so genau wie möglich darzustellen und
auf möglichst alle Optionen einzugehen.
%}}}

\subsection{Installation}
%{{{
Die Installation gestaltet sich denkbar einfach: Man besucht \deltor's
Blog, sucht den jeweils aktuellen Link und lädt eine Datei namens
\texttt{Physics.jar} herunter. Diese Datei muss dann in den Unterordner
\texttt{Plugins} des \aoi-Verzeichnisses kopiert werden. Fertig.

Um die Version~0.6.6 nutzen zu können, sollte man am besten \aoi
in der Version~2.7.2 verwenden. Für den Fall, dass \aoi noch gar nicht
installiert ist, kann man es sich unter folgender URL herunterladen:

\url{http://www.artofillusion.org}
%}}}

\subsection{Funktion und Einsatzzweck der Simulation}
%{{{
Wie der Name schon vermuten lässt, ist der primäre Zweck, Flüssigkeiten
zu simulieren. Diese entstehen in sogenannten \fachb{Emitters} und
interagieren dann mit als \fachb{Boundary} definierten Objekten in der
Szene.\footnote{Dem Plugin fehlt noch eine deutsche Übersetzung, daher
werde ich mich hier an die englischen Begriffe halten, um Verwirrung zu
vermeiden. Sollte der eine oder andere Begriff Probleme bereiten, dann
findet sich hier ein erstklassiges Online-Wörterbuch:
\url{http://dict.leo.org}} Alternativ kann man auch ganze Objekte
als \fachb{Fluid} vordefinieren, um auf einen Schlag viel Flüssigkeit in die
Szene zu bringen.

Mittlerweile beherrscht das Plugin jedoch auch die Simulation
sogenannter \fachb{Soft Bodies}. Damit sind Körper gemeint, die im
Wesentlichen deformierbar sind, also zum Beispiel Gummibälle oder
Textilien. Man kann damit in gewissem Rahmen zwar auch feste Körper
simulieren, stößt aber bald an die Grenzen. Die Gründe dafür werden
später näher erläutert. Eine richtige Simulation starrer Körper
(\fachb{Rigid Bodies}) wird es erst in Zukunft geben.

Das Plugin ist dabei auch tatsächlich eine \emph{Simulation}. Leider
steht das in einem gewissen Widerspruch zu dem ">Art"< in \aoi.
Simulationen versuchen, der Realität ähnlich zu sein, was zur Folge hat,
dass man sie nur sehr schwer kontrollieren kann. Es ist beispielsweise
nicht einfach, ein fertiges Bild, das das Anstoßen zweier Bierkrüge,
wobei der Inhalt des einen in den anderen überschwappt, mit der
\fluidsim ">mal eben"< etwas aufzupeppen. Stattdessen muss eine
Animation erstellt werden, welche die Bierkrüge im Vorfeld genau so
bewegt, dass die in ihnen enthaltene Flüssigkeit dann auch tatsächlich
im richtigen Moment ">schwappt"<.  Das ist nicht einfach, da sich die
Flüssigkeit realitätsgetreu verhält und man die Krüge nicht mit den
Händen \emph{anfassen} kann. Dadurch wird das Einschätzen der
vorhandenen Massen und wirkenden Kräfte zu keiner leichten Aufgabe.

Auf der anderen Seite ist aber genau das die Herausforderung.

Abgesehen von den künstlerischen Aspekten bietet die Simulation
natürlich eine großartige Spielwiese. Es macht einfach Spaß, einen Turm
aus Kisten zu bauen und dann zuzusehen, wie dieser durch Wasser
weggespült wird. Oder die Simulation einer Kegelbahn. Oder nachgebildete
Hydraulik, die vielleicht sogar einem kleinen Roboter Leben einhaucht.
Oder die realitätsgetreue Darstellung von Kleidung und Stoffen.
Zusammen mit \aoi's Fähigkeiten zur Animation bieten sich nahezu
unendliche Möglichkeiten, da hier auch Prozeduren und Skripte genutzt
werden können.

Ein bisschen Zukunftsmusik ist in diesen Beispielen allerdings noch
enthalten: Im Moment beherrscht das Plugin noch keine Reibung.

Nichtsdestotrotz: Viel Spaß!
%}}}

%}}}


\pagebreak
\section{Grundlagen}
%{{{

\subsection{Animationen und \fachb{Baking}}
%{{{
In der Einleitung fiel bereits das entscheidende Stichwort: Animation.
Die \fluidsim beschreibt Vorgänge, die sich zusammen mit der Zeit
verändern. Man kommt also nicht umhin, eine Animation zu erstellen --
auch, wenn man am Ende nur ein einzelnes Bild rendern möchte. Das wäre
zwar nicht allzu viel Arbeit (Animation ist schließlich eine der
Hauptaufgaben von \aoi), aber die \fluidsim nimmt sie uns großteils
sogar ab. Das Minimum ist jedoch, sich die \emph{Zeitleiste} zugänglich
zu machen. Im Normalfall muss man dazu nichts weiter tun, als den Rand
am unteren Ende des \aoi-Hauptfensters mit der Maus ein Stück nach oben
zu ziehen. Mit dieser Leiste ist es möglich, innerhalb einer Animation
zu navigieren.

\fpic{gfx/shots/TimeScore.png}{fig:timescore}
{\aoi mit sichtbarer Zeitleiste. An der orange markierten Stelle muss
gezogen werden, der grüne Schieber dient zum Setzen des Zeitpunktes.}

Mit den weiteren Möglichkeiten zur Animation muss man sich vorerst nicht
befassen. Wir werden allerdings später darauf zurückkommen, wenn wir das
Rendern von Einzelbildern hinter uns haben und uns um echte Animationen
kümmern.

Da die Berechnungen, welche die \fluidsim anstellt, ziemlich aufwändig
sind, können sie nicht in Echtzeit erfolgen. Die Simulation muss also
vor dem eigentlichen Rendern vorberechnet werden. Dieser Vorgang wird
\fachb{Baking} genannt und wird aus dem Plugin heraus angestoßen. Erst
hiernach hat es auch wirklich eine Auswirkung, wenn man den aktuellen
Zeitpunkt in der Zeitleiste verändert, und die Objekte bewegen sich.

Die Daten werden dabei in einer Datei zwischengespeichert. Man sollte
hier nicht zu geizig sein und sich mit einem fast vollen Datenträger
begnügen: Diese Datei kann bei langen Simulationen mehrere hundert
Megabyte groß werden.
%}}}

\subsection{Zeitschritte und Partikelgrößen}
%{{{
Eine physikalische Simulation läuft am Computer immer ">diskretisiert"<
ab, das heißt, es gibt nur eine endliche Anzahl fester Zeitpunkte, die
berechnet werden. Dazwischen gibt es zwangsweise ">Lücken"<. Daraus
folgt natürlich, dass eine Simulation dann genauer wird, wenn diese
Zeitpunkte näher beeinander liegen. Der Abstand zweier solcher
Zeitpunkte wird im Plugin \fachb{Step Size} genannt.

Man muss hier einen guten Kompromiss finden: Ist die Step Size zu groß,
dann ist die Simulation zwar sehr schnell berechnet, aber höchst
ungenau. Es kann dann passieren, dass Flüssigkeitspartikel ihre
Hindernisse ">überspringen"<. Wird die Step Size dagegen zu klein
gewählt, dauert es einfach zu lange, bis der Baking-Vorgang beendet
ist.\footnote{Eine schöne Anekdote zu diesem Thema findet sich übrigens
hier: \url{http://xkcd.com/505/}}

\fpic{gfx/skizzen/diskrfehler.pdf}{fig:diskrfehler}
{Ein simuliertes Partikel übersieht ein Hindernis durch eine zu große
Step Size.}

Die Flüssigkeiten werden intern als kleine Partikel fester Größe
modelliert, anhand des Parameters \fachb{Particle Size}. Wie man schon
erahnen kann, gilt hier ein ähnlicher Zusammenhang: Sind die Partikel
sehr klein, dann ist die Simulation sehr detailliert, aber langsam. Sind
sie zu groß, simuliert man irgendwann Fußbälle.

Bei beiden Parametern sind Werte voreingestellt, die für einfache
Beispiele ausreichend sind.

Man muss wissen, dass hier ein loser Zusammenhang herrscht. Verringert
man die Partikelgröße, dann sollte man auch die Zeitschritte verringern.
Eine feste Formel hierfür anzugeben, wäre aber nicht sonderlich
praktikabel. Der Grund für diesen Zusammenhang ist, dass kleinere
Partikel noch leichter Hindernisse überspringen oder gegenseitig
ineinander eindringen können, als dass bei größeren Partikeln der Fall
ist. Grob lässt sich sagen: Halbiert man die Particle Size, dann sollte
man auch die Step Size halbieren.

\fpic{gfx/skizzen/zshg-groesse-step.pdf}{fig:zshg-groesse-step}
{Bei größeren Partikeln wird noch eine Kollision erkannt, während
kleinere Partikel in derselben Simulation wieder durch das Objekt
tunneln.}

In Abbildung~\ref{fig:zshg-groesse-step} wird auch noch einmal die
grundsätzliche Bedeutung der Step Size deutlich: Auch die großen
Partikel würden durch das Hindernis tunneln, wenn sie sich schneller
bewegen würden. Eine höhere Geschwindigkeit heißt, dass die Partikel pro
Zeitschritt eine größere Distanz zurücklegen, wodurch natürlich die
Lücken zwischen ihnen größer werden. Damit steigt die Chance, dass ein
Teilchen ein Hindernis nicht wahrnimmt. Man muss also auch dann, wenn
man in einer Simulation hohe Geschwindigkeiten hat, eine kleine Step
Size wählen.

In ferner Zukunft soll es dafür eine Lösung geben und zwar eine adaptive
Step Size. Inwiefern das funktionieren und wann es überhaupt eingebaut
wird, ist aber noch offen.
%}}}

%}}}


\pagebreak
\section{Flüssigkeitssimulation}
%{{{

%{{{
Die konkrete Anwendung der \fluidsim erklärt man wohl am besten anhand
eines Beispiels. Im ersten Teil soll unser Ziel sein,
\itA
	\item ein gefülltes Becken mit Wasser zu erstellen
	\item und dann noch weiteres Wasser dazuzugießen.
\itE
%}}}

\subsection{Das gefüllte Becken (\fachb{Boundaries} und \fachb{Fluids})}
%{{{
Zuerst werden wir das Becken als Boundary definieren. Seit einiger Zeit
unterstützt das Plugin sogenannte \fachb{Poly Boundaries}, also Objekte,
deren \emph{Flächen} als Hindernis benutzt werden können.\footnote{In
älteren Versionen war das anders. Früher galten die Punkte eines
Objektes als Grenzen, was einiges an Zwischenarbeit erforderte.} Das
heißt für uns, dass wir ganz komfortabel ein \PolyMesh-Objekt in die
Szene bringen und dieses unverändert nutzen können. Tun wir das also und
erstellen uns ein sehr rudimentäres Becken. Um die Übersicht zu wahren,
nennen wir es um in ">Becken"<.

\fpic{gfx/shots/Becken1.png}{fig:becken1}
{Ein einfaches Becken.}

Wie eingangs erwähnt, lassen sich Objekte als Fluid definieren und
werden damit komplett flüssig. Genau das wollen wir jetzt nutzen: Wir
erstellen einen weiteren, einfachen \PolyMesh-Quader, den wir in das
Becken setzen. Noch ist er solide, aber das wird sich bald ändern. Wir
nennen ihn ">Fuellung"<.

\fpic{gfx/shots/Becken2.png}{fig:becken2}
{Das Becken mit (noch) solider Füllung.}

Um Objekten physikalische Eigenschaften zuordnen zu können, muss zuerst
eine Instanz des Fluid-Plugins zur Szene hinzugefügt werden. Man wählt
dazu einfach die blauen Tröpfchen aus der Toolbar aus und zieht ein
Rechteck auf. Was man im nächsten Schritt sieht, ist das Drahtgitter
eines Würfels. Dieser Bereich ist wichtig: Er definiert, wo
Flüssigkeiten existieren können und wo nicht. Verlassen Partikel diesen
Würfel, werden sie automatisch verschwinden. Es ist aber kein Problem,
den Bereich später einfach mit dem gewohnten Skalierungstool zu
erweitern.

Ein Doppelklick auf das neu erstellte Objekt in der Objektliste öffnet
seine Eigenschaften. Hier wird sich nun die ganze Magie abspielen.

Wir markieren das Objekt ">Becken"< in der mittleren
Liste.\rand{Boundary} Um einem Objekt Eigenschaften zuzuweisen, müssen
wir es erst in die aktuelle ">Auswahl"< übernehmen. Die
Begrifflichkeiten kollidieren hier leider etwas, denn diese Auswahl hat
nichts mit den \fachb{Selection Sets} in der linken Hälfte des Dialogs
zu tun -- zu denen kommen wir erst später. Die Auswahl, um die es hier
geht, bestimmt nur jene Objekte, auf die die gesetzten Parameter wirken.
Man könnte in der mittleren Liste also auch mehrere Objekte auf einmal
markieren und diese damit gleichzeitig bearbeiten.

Aus der rechten Dropdown-Liste wählen wir nun ">Boundry"<\footnote{Die
Rechtschreibfehler stehen weiter unten auf der ">TODO"<-Liste...} und
klicken auf ">Set To Selection"<. Es werden jetzt ein paar mehr Optionen
zugänglich, für unser Beispiel sind diese aber optimal.

Als nächstes erklären wir den inneren Quader zur
Flüssigkeit.\rand{Fluid} Auch dieser Vorgang gestaltet sich ziemlich
einfach: Das Objekt namens ">Fuellung"< aus der mittleren Liste wählen,
auf ">Set To Selection"< klicken und diesmal weisen wir ihm den Typ
">Fluid"< zu. Das war's.

\fpic{gfx/shots/Becken-Definitionen.png}{fig:becken-def}
{Die ersten zwei Objekte sind im Plugin definiert.}

Jetzt können wir auch schon den ersten ">Backvorgang"<
starten.\rand{Baking} Dazu wechseln wir auf den Tab ">Baking"<. Hier
kann man einen Zielort für die temporäre Datei angeben, der Standardwert
sollte aber vorübergehend ausreichen. Wichtig ist: Wenn man von vorne
mit der Simulation anfangen will, sollte man immer die beiden Knöpfe
betätigen:

\itA
	\item ">\textbf{Clear Object Cache}"<: Dieser Knopf signalisiert dem
	Plugin, dass es bitte alle zwischengespeicherten Informationen über
	die vorhandenen Objekte vergessen möge, vorallem deren Geometrie.
	Das heißt, diesen Knopf müsste man auch betätigen, wenn man im
	Nachhinein die Größe des Beckens ändern wollte.

	\item ">\textbf{Reset Simulation}"<: Dagegen sorgt dieser zweite
	Knopf dafür, dass sowohl die Zeit auf Null zurückgesetzt als auch
	alle bisher berechneten Bewegungen gelöscht werden. Das muss man
	also zusätzlich auslösen, wenn man sicherstellen will, dass die
	Simulation auch wirklich von vorne anfängt zu rechnen.

\itE

Im unteren Feld können wir noch eingeben, zu welchem Zeitpunkt die
Simulation enden soll. Dieser Zeitpunkt ist \emph{absolut}, das heißt,
er bestimmt \emph{nicht die Dauer} der Simulation. Wir schreiben also
eine ">2"< in das Feld, da wir von Sekunde 0 bis Sekunde 2 simulieren
wollen.

Nach einem Klick auf ">Bake"< erscheint ein Fortschrittsbalken, der aber
bald wieder verschwindet. Verlässt man nun das Plugin mit einem Klick
auf ">OK"< und bewegt danach den Schieber in der Zeitleiste etwas,
sollte man auch schon die ersten Anzeichen von Leben in der Flüssigkeit
entdecken können.

Bevor man ein halbwegs sinnvolles Bild rendern kann, heißt es jedoch:

\itA
	\item Licht muss in die Szene. Dieser Schritt ist trivial und zur
	Not schlage man im Handbuch\footnote{Hier die deutsche Übersetzung
	von Vidiot: \\
	\url{http://www.uninformativ.de/tutorials/Vidiot/AoI_Manual_2_6_ger/contents_de.html}}
	nach. ;-)

	\item Man will vermutlich das \PolyMesh-Objekt ">Fuellung"<
	verstecken. Der Grund dafür ist, dass das Setzen des Objektes auf
	">Fluid"< das originale Objekt nicht beeinflusst. Es dient quasi nur
	als Partikelquelle und ist daher im Normalfall im Weg.

	Keine Sorge, die Flüssigkeit wird dadurch nicht unsichtbar, denn
	diese ist Teil des Objektes ">PhysicsObject 1"<. Würde man also
	tatsächlich die Flüssigkeit \emph{nicht} rendern wollen, so müsste
	man das gesamte Physik-Objekt verstecken. Im Moment ist es noch
	nicht möglich, nur einzelne Teile des Physik-Objektes zu verstecken.

\itE

Abbildung~\ref{fig:render-becken1} zeigt dann, wie ein mögliches
Ergebnis aussehen kann.

\fpic{gfx/renders/Becken1.png}{fig:render-becken1}
{Ein erster Testrender der Szene mit transparentem Hintergrund.}
%}}}

\subsection{Erweiterte Optionen zum vorigen Beispiel}
%{{{
TODO: Was es sonst noch so die bis jetzt besprochenen Objekte betreffend gibt.
%}}}

\subsection{Gezielt Flüssigkeit dazugießen (\fachb{Emitters})}
%{{{
\fachb{Emitters} sind wie Fluids eine Möglichkeit, um Flüssigkeit
entstehen zu lassen. Anders als letztere können Emitters aber eher als
">Wasserhahn"< angesehen werden: Aus ihnen strömt Flüssigkeit mit einer
festen Geschwindigkeit in eine bestimmte Richtung.

Es ist nun so, dass Emitters noch ältere Programmteile sind und daher
vertexbasiert arbeiten. Für uns bedeutet das in erster Linie, dass wir
ein bisschen mehr Arbeit haben und zuerst einen ganz kurzen Ausflug in
die Geometrie machen müssen. Denn vorab muss geklärt werden, welche
Bedeutung ">Normalen"< im Allgemeinen und für die \fluidsim im
Speziellen haben.

\fpic{gfx/shots/Wings-Normalen.png}{fig:normalen1}
{Ein Screenshot aus Wings3D, hier lassen sich die Normalen eines Körpers
direkt anzeigen.}

Abbildung~\ref{fig:normalen1} zeigt einen einfachen Zylinder. Zu sehen
sind als kleine blaue Striche außerdem die Normalen: Die Normale einer
Fläche ist ein Vektor, der senkrecht auf dieser Fläche steht.

TODO: Genauer!

Wir werden gleich den ersten Emitter erstellen, welcher ein einfaches
\TriMesh sein wird. Wie bereits erwähnt, arbeiten Emitters vertexbasiert.
Das heißt, dass jeder Punkt in unserem \TriMesh Flüssigkeit erzeugen
wird. Doch in welche Richtung? Hier kommen jetzt die Normalen ins Spiel.
Normalen sind zwar eigentlich auf Flächen definiert, lassen sich aber
relativ einfach auf die angrenzenden Punkte übertragen. Man kann die
Normale für einen Punkt zum Beispiel bilden, indem man die Normalen
aller angrenzenden Flächen mittelt. Damit hat man eine ungefähre
Richtung definiert, entlang welcher unser Wasser fließen wird.

\aoi beherrscht Mechanismen, um in einem Mesh Vertexnormalen automatisch
aus Flächennormalen erzeugen zu können. Dafür gibt es verschiedene
Vorgehensweisen, aber nur eine davon garantiert uns maximale Kontrolle:
Wir müssen ein \TriMesh mit ">Shading"< als ">Smoothing Method"<
erstellen.

Der schnellste Weg, das zu tun, ist folgender:
\itA
	\item Wir klicken doppelt auf das \PolyMesh-Icon (sic!) und wählen
	dort als Template ein ">Flat Mesh"< aus. Die Größe setzen wir zum
	Beispiel auf 5x5. Die ">Smoothing Method"< in \emph{diesem} Dialog
	muss noch auf ">None"< gesetzt werden.

	\item Nachdem wir ein solches Objekt erstellt haben, wandeln wir es
	mit einem Rechtsklick in der Objektliste in ein \TriMesh um.

	\item Jetzt können wir unter der Objektliste in den Eigenschaften
	die ">Smoothing Method"< auf ">Shading"< setzen.

	\item Da wir dieses Objekt gleich als Emitter setzen wollen, nennen
	wir es auch so: ">Emitter"<.

\itE

Der Sinn dieses Umwegs ist folgender: Nur Shading errechnet korrekte
Vertexnormalen \emph{ohne} die Geometrie des Körpers zu
verändern.\footnote{Wer sich genauer dafür interessiert, kann sich
einmal die Methode \texttt{getWireframeMesh()} in
\texttt{TriangleMesh.java} des \aoi-Quelltextes ansehen.} Prinzipiell
spräche also nichts dagegen, statt des \TriMesh's ein \PolyMesh zu
verwenden -- leider entstehen bei letzteren manchmal falsch berechnete
Vertexnormalen, was bei \TriMesh's nicht der Fall ist.

TODO: Definition im Plugin
%}}}

\subsection{Erweiterte Optionen zum vorigen Beispiel}
%{{{
TODO: Normal Factor, ... 
%}}}

%}}}


\pagebreak
\section{Simulation deformierbarer Körper}
%{{{
TODO: Benutzung, Feder-Masse-System und so
%}}}


\pagebreak
\section{Weiterführende Techniken}
%{{{

\subsection{\fachb{Baking} fortsetzen}
%{{{
TODO: Wie das überhaupt geht, dabei Parameter ändern
%}}}

\subsection{\fachb{Selection Sets} zur Gruppierung}
%{{{
Mit Version~0.6.6 der \fluidsim wurde eine Integration mit dem
Selections-Plugin von \aoi geschaffen. Das ist insofern eine große
Vereinfachung, als damit massenhaft Objekten Werte zugeordnet werden
können. Außerdem wird die Übersicht erheblich erhöht. Daher lohnt es
sich, einen kurzen Blick auf dieses Plugin zu werfen. Falls es noch
nicht installiert ist, kann es über den Scripts and Plugins Manager
leicht nachinstalliert werden.

Die Grundidee des Selections-Plugins ist es, Objekte in logischen
Gruppen zusammenzufassen. Es kann noch ein bisschen mehr, zum Beispiel
Locking oder Ausblenden der Objekte, die für unseren Zweck aber nicht
ganz so interessant sind -- und überdies selbst\-er\-klä\-rend.

Die Bedienung ist recht einfach: Die Objekte, die man zusammenfassen
will, markiert man und klickt dann unter ">Selections"< auf ">New"<. Das
erstellt eine neue Gruppe, die automatisch all diese Objekte enthält. Da
jedoch nicht ganz offensichtlich ist, dass dies der Fall ist, kann mit
einem Doppelklick auf den Namen des Selection Sets ein neues
Dialogfenster mit einer Übersicht öffnen. In diesem neuen Dialog können
auch Objekte aus der Gruppe herausgenommen werden. Genauer gesagt: Was
hier markiert ist, gehört zur Gruppe.

Ein möglicher Anwendungsfall: Man hat sehr viele Kisten und möchte diese
später alle auf die gleiche Weise als Soft Body verwenden. Dazu fasst
man sie vorab zu einem Selection Set zusammen.

TODO: Explizites Beispiel
%}}}

\subsection{Texturieren und Rendern}
%{{{
TODO: Raster-Renderer empfehlen, Grid für den Raytracer und Möglichkeit,
IsoSurfaces bei selbigem auszuschalten
%}}}

\subsection{Animation}
%{{{
TODO:
%}}}

%}}}


\end{document}


% vim: set tw=72 foldmethod=marker :
